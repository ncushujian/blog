<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法复杂度</title>
    <link href="/blog/2021/04/07/20210407/"/>
    <url>/blog/2021/04/07/20210407/</url>
    
    <content type="html"><![CDATA[<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="什么是大O-？"><a href="#什么是大O-？" class="headerlink" title="什么是大O ？"></a>什么是大O ？</h2><p>n表示数据规模<br>O(f(n)) 表示运行算法所需要执行的指令数，和f(n)成正比。<br>寻找数组中的最大/最小值O(n),所需执行的指令数a*n,a是常数</p><p><img src="/blog/img/20210407/1.jpg" srcset="/blog/img/loading.gif" alt="算法.jpg"><br>算法A，表示对整个数据扫描一遍，每个数据要执行10000条指令。从图里面看出来，随着数据规模的增长，算法A要优于算法B。<br><img src="/blog/img/20210407/2.png" srcset="/blog/img/loading.gif" alt="指令执行次数的增长.png"></p><h2 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h2><ol><li>在学术界，严格的讲，O(f(n))表示算法执行的上界。什么是上界？比如归并排序的时间复杂度是O(nlogn)，同时也是O(n^2)。在业界，我们就用O来表示算法执行的最低上界，我们一般不会说归并排序的算法时间复杂度是O(n^2)的；</li><li>O(nlogn + n) = O(nlogn)，当数据量大到一定程度，O(nlogn)占主导。</li></ol><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>多开一个长度为n的辅助数组，空间复杂度就是O(n)<br>多开一个辅助的二维数组，空间复杂度就是O(n^2)<br>多开常数空间，O(1)      </p><p>递归的调用，是有空间代价的。如果递归的深度是n，空间复杂度就是O(n)</p><h1 id="常见的复杂度分析"><a href="#常见的复杂度分析" class="headerlink" title="常见的复杂度分析"></a>常见的复杂度分析</h1><p><img src="/blog/img/20210407/O(1).png" srcset="/blog/img/loading.gif" alt="O(1)复杂度"><br><img src="/blog/img/20210407/O(n).png" srcset="/blog/img/loading.gif" alt="O(n)复杂度"><br><img src="/blog/img/20210407/O(n%5E2).png" srcset="/blog/img/loading.gif" alt="O(n^2)复杂度"><br><img src="/blog/img/20210407/O(logn).png" srcset="/blog/img/loading.gif" alt="O(logn)复杂度"><br><img src="/blog/img/20210407/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95.png" srcset="/blog/img/loading.gif" alt="二分查找法"><br><img src="/blog/img/20210407/intToString.png" srcset="/blog/img/loading.gif" alt="intToString"></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法感悟</title>
    <link href="/blog/2021/04/06/20210406/"/>
    <url>/blog/2021/04/06/20210406/</url>
    
    <content type="html"><![CDATA[<ol><li>在刷题的时候，应该积极的找规律，并用代码去实现它；</li><li>自己给自己几个简单的测试用例，积极找规律，试验一下；</li><li>不要忽略暴力算法，暴力算法通常是思考的起点；</li><li>空间和时间的交换（哈希表）；</li><li>BFS广度优先搜索算法，本质上就是维护一个队列，入队列，出队列…然后DFS深度优先搜索算法，本质上就是维护一个栈，压栈，出栈…</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写实现简易版本的Promise</title>
    <link href="/blog/2020/10/13/20201013/"/>
    <url>/blog/2020/10/13/20201013/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;  <span class="hljs-keyword">static</span> STATE_MAPPING = &#123;    PENDING: <span class="hljs-string">'pending'</span>,    RESOLVED: <span class="hljs-string">'resolved'</span>,    REJECTED: <span class="hljs-string">'rejected'</span>,  &#125;  <span class="hljs-keyword">constructor</span>(props) &#123;    <span class="hljs-keyword">this</span>.status = MyPromise.STATE_MAPPING.PENDING;    <span class="hljs-keyword">this</span>.data = <span class="hljs-literal">undefined</span>;    <span class="hljs-keyword">this</span>.resolvedCallbacks = [];    <span class="hljs-keyword">this</span>.rejectedCallbacks = [];    <span class="hljs-keyword">this</span>.fn = props;    <span class="hljs-keyword">this</span>.doTask();  &#125;  doTask = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> &#123; resolve, reject &#125; = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">this</span>.fn(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (e) &#123;      reject(e);    &#125;  &#125;  resolve = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === MyPromise.STATE_MAPPING.PENDING) &#123;      <span class="hljs-keyword">this</span>.status = MyPromise.STATE_MAPPING.RESOLVED;      <span class="hljs-keyword">this</span>.data = data;      <span class="hljs-keyword">this</span>.resolvedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(data));    &#125;  &#125;  reject = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === MyPromise.STATE_MAPPING.PENDING) &#123;      <span class="hljs-keyword">this</span>.status = MyPromise.STATE_MAPPING.REJECTED;      <span class="hljs-keyword">this</span>.data = data;      <span class="hljs-keyword">this</span>.rejectedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(data));    &#125;  &#125;  handleResolve = <span class="hljs-function">(<span class="hljs-params">resolve, reject, handler</span>) =&gt;</span> &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">const</span> ret = handler(<span class="hljs-keyword">this</span>.data);      <span class="hljs-keyword">if</span> (ret <span class="hljs-keyword">instanceof</span> MyPromise) &#123;        ret.then(resolve, reject);      &#125; <span class="hljs-keyword">else</span> &#123;        resolve(ret);      &#125;    &#125; <span class="hljs-keyword">catch</span> (e) &#123;      reject(e);    &#125;  &#125;  handleReject = <span class="hljs-function">(<span class="hljs-params">resolve, reject, handler</span>) =&gt;</span> &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">const</span> ret = handler(<span class="hljs-keyword">this</span>.data);      <span class="hljs-keyword">if</span> (ret <span class="hljs-keyword">instanceof</span> MyPromise) &#123;        ret.then(resolve, reject);      &#125; <span class="hljs-keyword">else</span> &#123;        reject(ret);      &#125;    &#125; <span class="hljs-keyword">catch</span> (e) &#123;      reject(e);    &#125;  &#125;  then = <span class="hljs-function">(<span class="hljs-params">onFulfilled, onRejected</span>) =&gt;</span> &#123;    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">'function'</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v;    onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">'function'</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<span class="hljs-keyword">throw</span> e&#125;;    <span class="hljs-keyword">const</span> actions = &#123;      resolved: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>        <span class="hljs-keyword">this</span>.handleResolve(resolve, reject, onFulfilled)      )),      rejected: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>        <span class="hljs-keyword">this</span>.handleReject(resolve, reject, onRejected)      )),      pending: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">this</span>.resolvedCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>          <span class="hljs-keyword">this</span>.handleResolve(resolve, reject, onFulfilled)        ));        <span class="hljs-keyword">this</span>.rejectedCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>          <span class="hljs-keyword">this</span>.handleReject(resolve, reject, onRejected)        ));      &#125;),      <span class="hljs-keyword">default</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'sth may happened ~'</span>)      &#125;,    &#125;;    <span class="hljs-keyword">return</span> actions[<span class="hljs-keyword">this</span>.status]      ? actions[<span class="hljs-keyword">this</span>.status]()      : actions.default();  &#125;  <span class="hljs-keyword">catch</span> = <span class="hljs-function">(<span class="hljs-params">onRejected</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, onRejected);  &#125;&#125;<span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  reject(<span class="hljs-string">'失败'</span>);&#125;).then().then().then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功'</span>);&#125;, err =&gt; &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'失败'</span>);&#125;)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetCode刷题（六）二叉树题目集合</title>
    <link href="/blog/2020/10/11/20201011/"/>
    <url>/blog/2020/10/11/20201011/</url>
    
    <content type="html"><![CDATA[<p>题目编号：104<br><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a>   </p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    public int maxDepth(TreeNode root) &#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            int left = maxDepth(root.left);            int right = maxDepth(root.right);            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(left, right) + <span class="hljs-number">1</span>;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetCode刷题（五）动态规划</title>
    <link href="/blog/2020/10/01/20201001/"/>
    <url>/blog/2020/10/01/20201001/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li>最优子结构</li><li>边界</li><li>状态转移方程</li></ul><h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>题目编号：647<br><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">回文子串</a>   </p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> countSubstrings = <span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> &#123;  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> len = s.length;  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;    dp[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len).fill(<span class="hljs-literal">false</span>);  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= j; i++) &#123;      <span class="hljs-keyword">if</span> (i == j) &#123; <span class="hljs-comment">// 单个字符</span>        dp[i][j] = <span class="hljs-literal">true</span>;        count++;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j - i == <span class="hljs-number">1</span> &amp;&amp; s[i] == s[j]) &#123; <span class="hljs-comment">// 两个字符 </span>        dp[i][j] = <span class="hljs-literal">true</span>;        count++;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j - i &gt; <span class="hljs-number">1</span> &amp;&amp; s[i] == s[j] &amp;&amp; dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 多于两个字符</span>        dp[i][j] = <span class="hljs-literal">true</span>;        count++;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> count;&#125;;</code></pre><h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>题目编号：55<br><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">跳跃游戏</a><br>其实这题很简单，使用贪心算法倒推即可。但是潜意识觉得不可行，自己又没有弄几个测试用例去测，下次应该避免这样的情况。</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> canJump = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;  <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> numsLen = nums.length;  <span class="hljs-keyword">let</span> distance = <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (i = numsLen - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;    <span class="hljs-keyword">if</span> (nums[i] &gt;= distance) &#123;      distance = <span class="hljs-number">1</span>;      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) result = <span class="hljs-literal">true</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      distance++;    &#125;  &#125;  <span class="hljs-keyword">return</span> result;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>摄影基础知识</title>
    <link href="/blog/2020/07/18/20200718/"/>
    <url>/blog/2020/07/18/20200718/</url>
    
    <content type="html"><![CDATA[<h2 id="曝光"><a href="#曝光" class="headerlink" title="曝光"></a>曝光</h2><p>光线创造了纹理，光线和阴影形成了景物的纵深感。摄影一定是依赖于光线的，那么控制光线的秘诀就是理解曝光。</p><h3 id="什么是曝光？"><a href="#什么是曝光？" class="headerlink" title="什么是曝光？"></a>什么是曝光？</h3><p>生活中的例子：</p><ol><li>走出门外，强烈的光线让人不适应；</li><li>走进一个昏暗的房间，在眼睛适应黑暗之前几乎什么都看不到。</li></ol><p>眼睛的瞳孔，也就是黑色的部分，是一个可以调节半径来控制进光量的通道，它控制着合适的光量便于我们观察，因此在在室内的时候，瞳孔会比较大，获取更多的进光。</p><p><img src="/blog/img/20200718/1.png" srcset="/blog/img/loading.gif" alt="1.png"></p><p>相机的工作原理和我们的眼睛很相似。</p><p>相机有两个控制光线的机制：<code>光圈</code>和<code>快门</code></p><h2 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h2><h3 id="什么是快门？"><a href="#什么是快门？" class="headerlink" title="什么是快门？"></a>什么是快门？</h3><p>快门是一个控制传感器（或者胶片）接触光线的时间长短的机制，快门打开的时间越长，更多的光线接触图像传感器，让你的图像变得更亮。</p><h3 id="数码相机中的快门"><a href="#数码相机中的快门" class="headerlink" title="数码相机中的快门"></a>数码相机中的快门</h3><p>在现如今的数码相机中，快门由两个“幕帘”组成。当按下快门按钮，第一个幕帘开始滑开，随即第二个幕帘开始关闭，两个幕帘之间的间隙划过传感器，得到曝光。当光线暗的时候，需要长时间的曝光，光线充足的时候，需要短时间的曝光。</p><h3 id="快门的速度"><a href="#快门的速度" class="headerlink" title="快门的速度"></a>快门的速度</h3><p>快门的速度一般是用单位秒来计算的。因为快门的时间一般都比较短，所以通常使用分数。<br><img src="/blog/img/20200718/2.png" srcset="/blog/img/loading.gif" alt="2.png"><br>快门时间可以很长，比如在非常黑暗的环境下，快门速度可以达到几秒、几分钟甚至是一小时。</p><h2 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h2><h3 id="什么是光圈？"><a href="#什么是光圈？" class="headerlink" title="什么是光圈？"></a>什么是光圈？</h3><p>光圈一般处于镜头中，而不是相机中，是由一组叶片构成的连锁结构。<br><img src="/blog/img/20200718/3.png" srcset="/blog/img/loading.gif" alt="3.png"><br>孔径使用“f”档表示，它是光圈与焦距的比值。每一个光圈孔径都对应一个f比值，例： f/4、f/8、f/11<br><img src="/blog/img/20200718/4.png" srcset="/blog/img/loading.gif" alt="4.png"></p><h2 id="按下快门"><a href="#按下快门" class="headerlink" title="按下快门"></a>按下快门</h2><p>目前市面上的单反，拍照都需要半按快门按钮，仔细感觉一下快门按钮，感觉一下按下的过程，其实并不是一按到底，中间有一些小停顿。</p><h3 id="半按快门的时候，相机都做了什么？"><a href="#半按快门的时候，相机都做了什么？" class="headerlink" title="半按快门的时候，相机都做了什么？"></a>半按快门的时候，相机都做了什么？</h3><p>计算一些参数来完成拍摄，首先相机会自动对焦，分析当前的光照情况，计算快门速度和光圈大小，保证得到合适的曝光，最后，相机会计算一下白平衡，这个过程保证图片不会产生严重的偏色。</p><h2 id="自动对焦"><a href="#自动对焦" class="headerlink" title="自动对焦"></a>自动对焦</h2><p>人的眼睛所能集中注意的区域，只有伸开胳膊后的拇指差不多大。相机的自动对焦时候的选定的是某一个距离，在这个距离上的物体都会是清晰的，而且对焦点会亮起，当按下快门的时候，要确保焦点位置的正确。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Google V8引擎学习笔记（一）</title>
    <link href="/blog/2020/07/17/20200717/"/>
    <url>/blog/2020/07/17/20200717/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是V8？"><a href="#什么是V8？" class="headerlink" title="什么是V8？"></a>什么是V8？</h2><p>V8 看成是一个虚构出来的计算机，也称为虚拟机，虚拟机通过模拟实际计算机的各种功能来实现代码的执行，如模拟实际计算机的 CPU、堆栈、寄存器等，虚拟机还具有它自己的一套指令系统。</p><h2 id="V8引擎执行JavaScript代码前做了哪些准备工作？"><a href="#V8引擎执行JavaScript代码前做了哪些准备工作？" class="headerlink" title="V8引擎执行JavaScript代码前做了哪些准备工作？"></a>V8引擎执行JavaScript代码前做了哪些准备工作？</h2><p>在 V8 启动执行 JavaScript 之前，它还需要准备执行 JavaScript 时所需要的一些基础环境，这些基础环境包括了“堆空间”“栈空间”“全局执行上下文”“全局作用域”“消息循环系统”“内置函数”等，这些内容都是在执行 JavaScript 过程中需要使用到的，比如：</p><ol><li>JavaScript 全局执行上下文就包含了执行过程中的全局信息，比如一些内置函数，全局变量等信息；</li><li>全局作用域包含了一些全局变量，在执行过程中的数据都需要存放在内存中；</li><li>而 V8 是采用了经典的堆和栈的内存管理模式，所以 V8 还需要初始化内存中的堆和栈结构；</li><li>另外，想要我们的 V8 系统活起来，还需要初始化消息循环系统，消息循环系统包含了消息驱动器和消息队列，它如同 V8 的心脏，不断接受消息并决策如何处理消息。</li></ol><h2 id="V8引擎执行JavaScript代码的流程？"><a href="#V8引擎执行JavaScript代码的流程？" class="headerlink" title="V8引擎执行JavaScript代码的流程？"></a>V8引擎执行JavaScript代码的流程？</h2><ol><li>一段简单的JS代码 ；<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">"test"</span>;</code></pre></li><li>首先被解析器优化成AST语法树，在生成AST语法树的同时，还会生成作用域；</li><li>AST树转换成字节码；</li><li>最后交给解释器执行。</li></ol><p><img src="/blog/img/20200717/1.png" srcset="/blog/img/loading.gif" alt="1.png"></p><h2 id="原始值与引用值"><a href="#原始值与引用值" class="headerlink" title="原始值与引用值"></a>原始值与引用值</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PWA使用调研</title>
    <link href="/blog/2020/05/03/20200503/"/>
    <url>/blog/2020/05/03/20200503/</url>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>​        PWA应用是指那些使用指定技术和标准模式来开发的web应用，这将同时赋予它们web应用和原生应用的特性。例如：</p><ul><li><p><a href="https://developer.mozilla.org/en-US/Apps/Progressive/Advantages#Discoverable" target="_blank" rel="noopener">Discoverable</a>, 内容可以通过搜索引擎发现。</p></li><li><p><a href="https://developer.mozilla.org/en-US/Apps/Progressive/Advantages#Installable" target="_blank" rel="noopener">Installable</a>, 可以出现在设备的主屏幕。</p></li><li><p><a href="https://developer.mozilla.org/Apps/Progressive/Advantages#Linkable" target="_blank" rel="noopener">Linkable</a>, 你可以简单地通过一个URL来分享它。 </p></li><li><p><a href="https://developer.mozilla.org/en-US/Apps/Progressive/Advantages#Network_independent" target="_blank" rel="noopener">Network independent</a>, 它可以在离线状态或者是在网速很差的情况下运行。</p></li><li><p><a href="https://developer.mozilla.org/en-US/Apps/Progressive/Advantages#Progressive" target="_blank" rel="noopener">Progressive</a>, 它在老版本的浏览器仍旧可以使用，在新版本的浏览器上可以使用全部功能。</p></li><li><p><a href="https://developer.mozilla.org/en-US/Apps/Progressive/Advantages#Re-engageable" target="_blank" rel="noopener">Re-engageable</a>, 无论何时有新的内容它都可以发送通知。</p></li><li><p><a href="https://developer.mozilla.org/en-US/Apps/Progressive/Advantages#Responsive" target="_blank" rel="noopener">Responsive</a>, 它在任何具有屏幕和浏览器的设备上可以正常使用——包括手机，平板电脑，笔记本，电视，冰箱，等。</p></li><li><p><a href="https://developer.mozilla.org/en-US/Apps/Progressive/Advantages#Safe" target="_blank" rel="noopener">Safe</a>, 在你和应用之间的连接是安全的，可以阻止第三方访问你的敏感数据。</p></li></ul><h2 id="2-demo"><a href="#2-demo" class="headerlink" title="2. demo"></a>2. demo</h2><p>service worker能劫持所有的网络请求，安全原因必须要在https或者localhost下运行。以下是一个项目地址为 <a href="https://mdn.github.io/sw-test" target="_blank" rel="noopener">https://mdn.github.io/sw-test</a> 的例子，步骤如下：</p><h4 id="2-1-注册"><a href="#2-1-注册" class="headerlink" title="2.1 注册"></a>2.1 注册</h4><pre><code class="hljs scilab"><span class="hljs-keyword">if</span> (<span class="hljs-string">'serviceWorker'</span> in navigator) &#123;  navigator.serviceWorker.register(<span class="hljs-string">'/sw-test/sw.js'</span>, &#123; scope: <span class="hljs-string">'/sw-test/'</span> &#125;)  .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(reg)</span> &#123;</span>    <span class="hljs-comment">// registration worked</span>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Registration succeeded. Scope is '</span> + reg.scope);  &#125;)  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> &#123;</span>    <span class="hljs-comment">// registration failed</span>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Registration failed with '</span> + <span class="hljs-built_in">error</span>);  &#125;);&#125;</code></pre><p>该段代码检测是否支持serviceWorker，支持的话注册/sw-test/sw.js（url 是相对于域名），scope选填，表示service worker影响范围（该范围不能比注册的地方大，在该例子中，最大就是/sw-test/。除非后端设置了Service-Worker-Allowed），默认是当前路径(<a href="https://mdn.github.io/sw-test" target="_blank" rel="noopener">https://mdn.github.io/sw-test</a>)</p><h4 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h4><p>Sw.js中完成具体逻辑，如下：</p><pre><code class="hljs stata">this.addEventListener('install', function(event) &#123;  event.waitUntil(    caches.<span class="hljs-keyword">open</span>('v1').then(function(cache) &#123;      <span class="hljs-keyword">return</span> cache.addAll([        '/<span class="hljs-keyword">sw</span>-<span class="hljs-keyword">test</span>/',        '/<span class="hljs-keyword">sw</span>-<span class="hljs-keyword">test</span>/index.html',        '/<span class="hljs-keyword">sw</span>-<span class="hljs-keyword">test</span>/style.css',        '/<span class="hljs-keyword">sw</span>-<span class="hljs-keyword">test</span>/<span class="hljs-keyword">app</span>.js',        '/<span class="hljs-keyword">sw</span>-<span class="hljs-keyword">test</span>/image-<span class="hljs-keyword">list</span>.js',        '/<span class="hljs-keyword">sw</span>-<span class="hljs-keyword">test</span>/star-wars-logo.jpg',        '/<span class="hljs-keyword">sw</span>-<span class="hljs-keyword">test</span>/gallery/',        '/<span class="hljs-keyword">sw</span>-<span class="hljs-keyword">test</span>/gallery/bountyHunters.jpg',        '/<span class="hljs-keyword">sw</span>-<span class="hljs-keyword">test</span>/gallery/myLittleVader.jpg',        '/<span class="hljs-keyword">sw</span>-<span class="hljs-keyword">test</span>/gallery/snowTroopers.jpg'      ]);    &#125;)  );&#125;);</code></pre><ul><li>Event.waitUntil确保Service Worker 不会在 <code>waitUntil()</code> 里面的代码执行完毕之前安装完成。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open" target="_blank" rel="noopener"><code>caches.open()</code></a> 方法来创建了一个叫做 <code>v1</code> 的新的缓存</li><li><code>addAll()</code>这个方法的参数是一个由一组相对于 origin 的 URL 组成的数组，这些 URL 就是你想缓存的资源的列表，他会马上去加载一次这些资源，并且缓存。</li></ul><p>当promise被reject的时候，安装失败，反之安装成功，service worker就会激活。</p><h4 id="2-3-劫持"><a href="#2-3-劫持" class="headerlink" title="2.3 劫持"></a>2.3 劫持</h4><p>每次任何被 service worker 控制的资源被请求到时，都会触发 <code>fetch</code> 事件，这些资源包括了指定的 scope 内的文档，和这些文档内引用的其他任何资源（比如 <code>index.html</code> 发起了一个跨域的请求来嵌入一个图片，这个也会通过 service worker 。）</p><pre><code class="hljs js"><span class="hljs-keyword">this</span>.addEventListener(<span class="hljs-string">'fetch'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;  event.respondWith(    caches.match(event.request)  );&#125;);</code></pre><p>以上例子只是简单的响应这些缓存中的 url  和网络请求匹配的资源。</p><h2 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3. 生命周期"></a>3. 生命周期</h2><ul><li><p>Installing</p><p>安装sw，执行install钩子。可以进行一些资源缓存，数据初始化（indexedDB）</p></li><li><p>installed</p><p>已经安装完成，等待使用了旧版本的sw的页面关闭</p></li><li><p>activating</p><p>激活sw，执行active钩子</p></li><li><p>activate</p><p>激活成功之后才能开始管控页面，fetch这些钩子才开始有效</p></li><li><p>redundant</p><p>失败获取被其他sw取代</p></li></ul><h2 id="4-更新顺序"><a href="#4-更新顺序" class="headerlink" title="4. 更新顺序"></a>4. 更新顺序</h2><ol><li><p>页面上通过navigator.serviceWorker.register来获取和注册。</p></li><li><p>受 service worker 控制的页面打开后会尝试去安装 service worker。最先发送给 service worker 的事件是安装事件(在这个事件里可以开始进行填充 IndexDB和缓存站点资源)。这个流程同原生 APP 或者 Firefox OS APP 是一样的 — 让所有资源可离线访问。</p></li><li><p>当 <code>oninstall</code>事件的处理程序执行完毕后，可以认为 service worker 安装完成了。</p></li><li><p>下一步是激活。当 service worker 安装完成后，会接收到一个激活事件(activate event)。 <code>onactivate</code>主要用途是清理先前版本的service worker 脚本中使用的资源。</p></li><li><p>重新刷新页面，会检测sw.js有无变化。没变化，不会重新在浏览器注册一个新的service worker(install钩子不会执行)，还是用旧的；有变化，会重新注册一个sw。期间，install钩子会直接执行，但是activate和其他不会执行，所以一般在activate清空上个版本的service worker相关缓存，等待使用旧的sevice worker的页面都关闭后，再激活新的service worker（如果使用了skipWaiting函数即可直接跳过install阶段）。未激活的service worker谷歌显示如下：</p><p><img src="/blog/img/20200503/image-20200527163404854.png" srcset="/blog/img/loading.gif" alt="image-20200527163404854"></p><p>下次再打开页面的时候，同时触发install和activate钩子</p></li><li><p>Service Worker 现在可以控制页面了，但仅是在 <code>register()</code> 成功后的打开的页面。也就是说，页面起始于有或则没有 service worker ，且在页面的接下来生命周期内维持这个状态。所以，页面不得不重新加载以让 service worker 获得完全的控制。（在activate钩子里使用clients.claim可以立即接管页面）</p></li></ol><h2 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h2><h3 id="5-1-全局变量"><a href="#5-1-全局变量" class="headerlink" title="5.1 全局变量"></a>5.1 全局变量</h3><p>service worker运行在浏览器独立的线程，因此没有获取dom的权限。单个 service worker 可以控制很多页面。每个你的 scope 里的页面加载完的时候，安装在页面的 service worker 可以控制它。牢记你需要小心 service worker 脚本里的全局变量： 每个页面不会有自己独有的worker。</p><h3 id="5-2-部分对象不可用"><a href="#5-2-部分对象不可用" class="headerlink" title="5.2 部分对象不可用"></a>5.2 部分对象不可用</h3><p>如window、localStorage、XMLHttpRequest在sw的上下文里是undefined，不确定的api用之前先测试一下。</p><h3 id="5-3-域名"><a href="#5-3-域名" class="headerlink" title="5.3 域名"></a>5.3 域名</h3><p>只能在https和localhost里面使用service worker，本地测试的时候请使用localhost(127.0.0.1实测也行)，用其他ip都不行，’serviceWorker’ in navigator会返回false</p><h3 id="5-4-不要更改service-worker文件名"><a href="#5-4-不要更改service-worker文件名" class="headerlink" title="5.4 不要更改service worker文件名"></a>5.4 不要更改service worker文件名</h3><p>启用离线访问的情况下，首页（index.html）会被sw(service worker)缓存。如果sw文件名称修改了，因为首页被缓存了，注册的sw文件路径还是旧的，所以根本不会启用新的sw（找不到sw文件并不会删除或更新sw）。</p><h3 id="5-5-调试"><a href="#5-5-调试" class="headerlink" title="5.5 调试"></a>5.5 调试</h3><p>由于service worker独立存在，所以错误的service worker可能会导致页面不可访问等其他情况。可以先去application选项卡把service worker清除</p><p><img src="/blog/img/20200503/image-20200527151840562.png" srcset="/blog/img/loading.gif" alt="image-20200527151840562"></p><h2 id="6-各api兼容性"><a href="#6-各api兼容性" class="headerlink" title="6.各api兼容性"></a>6.各api兼容性</h2><p>和service worker配套使用的api支持情况和service worker本身不一致，支持情况如下</p><h3 id="6-1-serviceWorker"><a href="#6-1-serviceWorker" class="headerlink" title="6.1 serviceWorker"></a>6.1 serviceWorker</h3><p><img src="/blog/img/20200503/image-20200528190447870.png" srcset="/blog/img/loading.gif" alt="image-20200528190447870">    </p><h3 id="6-2-caches"><a href="#6-2-caches" class="headerlink" title="6.2 caches"></a>6.2 caches</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage" target="_blank" rel="noopener">caches对象mdn介绍</a>。有match、 has、open、delete和keys四个函数，都是返回promise。兼容如下图</p><p><img src="/blog/img/20200503/image-20200527134243932.png" srcset="/blog/img/loading.gif" alt="image-20200527134243932"></p><h3 id="6-3-fetch"><a href="#6-3-fetch" class="headerlink" title="6.3 fetch"></a>6.3 fetch</h3><p><img src="/blog/img/20200503/image-20200527144635398.png" srcset="/blog/img/loading.gif" alt="image-20200527144635398"></p><h3 id="6-4-结论"><a href="#6-4-结论" class="headerlink" title="6.4 结论"></a>6.4 结论</h3><p>直接service worker的就一定支持cache和fetch(2，3项功能不行)，所以用如下代码即可：</p><pre><code class="hljs scilab"><span class="hljs-keyword">if</span> (<span class="hljs-string">'serviceWorker'</span> in navigator) &#123;      console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'支持service worker'</span>)      navigator.serviceWorker.register(<span class="hljs-string">'&lt;%= process.env.VUE_APP_PWA_PATH %&gt;service-worker.js'</span>)      .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(reg)</span> &#123;</span>        <span class="hljs-comment">// registration worked</span>        console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Registration succeeded. Scope is '</span> + reg.scope);      &#125;)      .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> &#123;</span>        <span class="hljs-comment">// registration failed</span>        console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Registration failed with '</span> + <span class="hljs-built_in">error</span>);      &#125;);    &#125; <span class="hljs-keyword">else</span> &#123;      console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'不支持service worker'</span>)    &#125;</code></pre><h2 id="7-手机实测"><a href="#7-手机实测" class="headerlink" title="7.手机实测"></a>7.手机实测</h2><p>安卓app（x5）： 支持navigator.serviceWorker属性, 但是install钩子不执行，原因未明</p><p>安卓app：<img src="/blog/img/20200503/image-20200601105517390.png" srcset="/blog/img/loading.gif" alt="image-20200601105517390"></p><p>安卓自带浏览器： 正常。由于连手机无法正常查看浏览器相关cache。接口时间对比如下（http和https）：</p><p><img src="/blog/img/20200503/image-20200531133132867.png" srcset="/blog/img/loading.gif" alt="image-20200531133132867"></p><p><img src="/blog/img/20200503/image-20200531133427630.png" srcset="/blog/img/loading.gif" alt="image-20200531133427630"></p><p>Ios safari：</p><p><img src="/blog/img/20200503/image-20200531134344522.png" srcset="/blog/img/loading.gif" alt="image-20200531134333522"><br><img src="/blog/img/20200503/image-20200531134333522.png" srcset="/blog/img/loading.gif" alt="image-20200531134333522"></p><p>iOS app：不支持。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>不使用 brew，如何安装 zsh ？</title>
    <link href="/blog/2019/11/19/20191119/"/>
    <url>/blog/2019/11/19/20191119/</url>
    
    <content type="html"><![CDATA[<p>第一步：克隆oh my zsh这个项目到本地</p><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code></pre><p>第二步：创建一个zsh的配置文件（注：如果之前已经存在，记得备份！）–非必须</p><pre><code class="hljs jboss-cli">cp ~<span class="hljs-string">/.zshrc</span> ~<span class="hljs-string">/.zshrc.orig</span></code></pre><p>第三步：创建zsh的配置文件</p><pre><code class="hljs awk">cp ~<span class="hljs-regexp">/.oh-my-zsh/</span>templates<span class="hljs-regexp">/zshrc.zsh-template ~/</span>.zshrc</code></pre><p>第四步：设置zsh为你的默认的shell</p><pre><code class="hljs awk">chsh -s <span class="hljs-regexp">/bin/</span>zsh</code></pre><p>第五步：重新打开一个命令窗口，使用zsh</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>brew如何使用国内镜像源？</title>
    <link href="/blog/2019/11/18/20191118/"/>
    <url>/blog/2019/11/18/20191118/</url>
    
    <content type="html"><![CDATA[<h3 id="brew使用国内镜像源"><a href="#brew使用国内镜像源" class="headerlink" title="brew使用国内镜像源"></a>brew使用国内镜像源</h3><pre><code class="hljs dsconfig"><span class="hljs-comment"># 步骤一</span><span class="hljs-string">cd </span><span class="hljs-string">"$(brew --repo)"</span><span class="hljs-string">git </span><span class="hljs-string">remote </span><span class="hljs-built_in">set-url</span> <span class="hljs-string">origin </span><span class="hljs-string">https:</span>//<span class="hljs-string">mirrors.</span><span class="hljs-string">tuna.</span><span class="hljs-string">tsinghua.</span><span class="hljs-string">edu.</span><span class="hljs-string">cn/</span><span class="hljs-string">git/</span><span class="hljs-string">homebrew/</span><span class="hljs-string">brew.</span><span class="hljs-string">git</span><span class="hljs-string"></span><span class="hljs-string">#</span> 步骤二<span class="hljs-string">cd </span><span class="hljs-string">"$(brew --repo)/Library/Taps/homebrew/homebrew-core"</span><span class="hljs-string">git </span><span class="hljs-string">remote </span><span class="hljs-built_in">set-url</span> <span class="hljs-string">origin </span><span class="hljs-string">https:</span>//<span class="hljs-string">mirrors.</span><span class="hljs-string">tuna.</span><span class="hljs-string">tsinghua.</span><span class="hljs-string">edu.</span><span class="hljs-string">cn/</span><span class="hljs-string">git/</span><span class="hljs-string">homebrew/</span><span class="hljs-string">homebrew-core.</span><span class="hljs-string">git</span><span class="hljs-string"></span><span class="hljs-string">#</span> 步骤三<span class="hljs-string">brew </span><span class="hljs-string">update</span></code></pre><p>注意这里需要等待一会，因为要更新资源。<br>更新完后使用brew update，brew install速度变快很多了，不会卡在那半天没动静，替换镜像完成。</p><h3 id="复原"><a href="#复原" class="headerlink" title="复原"></a>复原</h3><pre><code class="hljs dsconfig"><span class="hljs-string">cd </span><span class="hljs-string">"$(brew --repo)"</span><span class="hljs-string">git </span><span class="hljs-string">remote </span><span class="hljs-built_in">set-url</span> <span class="hljs-string">origin </span><span class="hljs-string">https:</span>//<span class="hljs-string">github.</span><span class="hljs-string">com/</span><span class="hljs-string">Homebrew/</span><span class="hljs-string">brew.</span><span class="hljs-string">git</span><span class="hljs-string"> </span><span class="hljs-string">cd </span><span class="hljs-string">"$(brew --repo)/Library/Taps/homebrew/homebrew-core"</span><span class="hljs-string">git </span><span class="hljs-string">remote </span><span class="hljs-built_in">set-url</span> <span class="hljs-string">origin </span><span class="hljs-string">https:</span>//<span class="hljs-string">github.</span><span class="hljs-string">com/</span><span class="hljs-string">Homebrew/</span><span class="hljs-string">homebrew-core</span><span class="hljs-string"> </span><span class="hljs-string">brew </span><span class="hljs-string">update</span></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetCode刷题（四）链表</title>
    <link href="/blog/2019/09/13/20190913/"/>
    <url>/blog/2019/09/13/20190913/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><p>题目编号：707<br><a href="https://leetcode-cn.com/problems/design-linked-list/" target="_blank" rel="noopener">设计链表</a></p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 链表节点构造函数</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">val</span>) </span>&#123;  <span class="hljs-keyword">this</span>.val = val;  <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Initialize your data structure here.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> MyLinkedList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">this</span>.head = <span class="hljs-literal">null</span>;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取指定索引的node节点</span><span class="hljs-comment"> */</span>MyLinkedList.prototype.getNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>&#123;  <span class="hljs-keyword">var</span> curIndex = <span class="hljs-number">0</span>;  <span class="hljs-keyword">var</span> curNode = <span class="hljs-keyword">this</span>.head;  <span class="hljs-keyword">if</span> (curNode) &#123;    <span class="hljs-keyword">while</span>(curNode.next !== <span class="hljs-literal">null</span> &amp;&amp; curIndex &lt; index) &#123;      curNode = curNode.next;      curIndex++;    &#125;    <span class="hljs-keyword">return</span> curIndex === index ? curNode : <span class="hljs-number">-1</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Get the value of the index-th node in the linked list. If the index is invalid, return -1. </span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">index</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span>MyLinkedList.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>&#123;  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.getNode(index);  <span class="hljs-keyword">return</span> node !== <span class="hljs-number">-1</span> ? node.val : <span class="hljs-number">-1</span>;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. </span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">val</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment"> */</span>MyLinkedList.prototype.addAtHead = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(val);  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.head) node.next = <span class="hljs-keyword">this</span>.head;  <span class="hljs-keyword">this</span>.head = node;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Append a node of value val to the last element of the linked list. </span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">val</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment"> */</span>MyLinkedList.prototype.addAtTail = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;  <span class="hljs-keyword">var</span> curNode = <span class="hljs-keyword">this</span>.head;  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(val);  <span class="hljs-keyword">if</span> (curNode.next === <span class="hljs-literal">null</span>) &#123;    curNode.next = node;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">while</span>(curNode.next !== <span class="hljs-literal">null</span>) &#123;      curNode = curNode.next;      <span class="hljs-keyword">if</span> (curNode.next === <span class="hljs-literal">null</span>) &#123;        curNode.next = node;        <span class="hljs-keyword">break</span>;      &#125;    &#125;  &#125;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. </span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>index </span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">val</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment"> */</span>MyLinkedList.prototype.addAtIndex = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index, val</span>) </span>&#123;  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(val);  <span class="hljs-keyword">var</span> prev = index - <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span> (prev &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">this</span>.addAtHead(val);  <span class="hljs-keyword">var</span> prevNode = <span class="hljs-keyword">this</span>.getNode(prev);  <span class="hljs-keyword">if</span> (prevNode) &#123;    node.next = prevNode.next;    prevNode.next = node;  &#125;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Delete the index-th node in the linked list, if the index is valid. </span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">index</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment"> */</span>MyLinkedList.prototype.deleteAtIndex = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>&#123;  <span class="hljs-keyword">var</span> delNode = <span class="hljs-keyword">this</span>.getNode(index);  <span class="hljs-keyword">if</span> (delNode !== <span class="hljs-number">-1</span>) &#123;    <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">this</span>.head.next;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">var</span> prev = index - <span class="hljs-number">1</span>;      <span class="hljs-keyword">var</span> prevNode = <span class="hljs-keyword">this</span>.getNode(prev);      prevNode.next = delNode.next;    &#125;  &#125;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your MyLinkedList object will be instantiated and called as such:</span><span class="hljs-comment"> * var obj = new MyLinkedList()</span><span class="hljs-comment"> * var param_1 = obj.get(index)</span><span class="hljs-comment"> * obj.addAtHead(val)</span><span class="hljs-comment"> * obj.addAtTail(val)</span><span class="hljs-comment"> * obj.addAtIndex(index,val)</span><span class="hljs-comment"> * obj.deleteAtIndex(index)</span><span class="hljs-comment"> */</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>方法逐步累加，确保前面的方法考虑情况周全，后续使用不会出问题；</li><li>本题的解题顺序最好是先写生成链表结构的代码，编写测试代码，例如 <code>travel()</code>，检验链表结构是否生成正确，随后才补充操作链表的相关方法，其它的题目也应该进行合理的模块拆分。</li></ol><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>题目编号：206<br><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;ListNode&#125;</span> <span class="hljs-variable">head</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ListNode&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> reverseList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!head || !head.next) <span class="hljs-keyword">return</span> head;  <span class="hljs-keyword">let</span> reverseHead = head;  <span class="hljs-keyword">while</span> (head.next) &#123;    <span class="hljs-keyword">let</span> preHeadNode = reverseHead;    <span class="hljs-keyword">let</span> rdNode = head.next.next;    reverseHead = head.next;    reverseHead.next = preHeadNode;    head.next = rdNode;  &#125;  <span class="hljs-keyword">return</span> reverseHead;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetCode刷题（三）二叉树层序遍历</title>
    <link href="/blog/2019/09/12/20190912/"/>
    <url>/blog/2019/09/12/20190912/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h2><p>题目编号：102<br><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树层序遍历</a></p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * function TreeNode(val) &#123;</span><span class="hljs-comment"> *     this.val = val;</span><span class="hljs-comment"> *     this.left = this.right = null;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;  <span class="hljs-keyword">var</span> r = [];  <span class="hljs-keyword">var</span> queue = [];  queue.push(root);  <span class="hljs-keyword">var</span> traverse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;     <span class="hljs-keyword">if</span> (!node.floor) node.floor = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (node.left) &#123;      node.left.floor = node.floor + <span class="hljs-number">1</span>;      queue.push(node.left);    &#125;    <span class="hljs-keyword">if</span> (node.right) &#123;      node.right.floor = node.floor + <span class="hljs-number">1</span>;      queue.push(node.right);    &#125;    !r[node.floor] &amp;&amp; (r[node.floor] = []);    r[node.floor].push(node.val);    queue.shift();    traverse(queue[<span class="hljs-number">0</span>]);  &#125;  traverse(root);  <span class="hljs-keyword">return</span> r;&#125;;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>这题采用了BFS和递归实现，在使用递归的时候，出现的栈溢出的情况，因此写完代码，应该考虑到遍历两层树的情况；</li><li>BFS算法为基石，需要其它变量辅助判断第几层，例如: <code>floor</code>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetCode刷题（二）栈和深度优先搜索算法</title>
    <link href="/blog/2019/09/11/20190911/"/>
    <url>/blog/2019/09/11/20190911/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="leetCode"><a href="#leetCode" class="headerlink" title="leetCode"></a>leetCode</h2><p>题目编号：20<br><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> isValid = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;  <span class="hljs-keyword">if</span>(s === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-keyword">var</span> stack = [];  <span class="hljs-keyword">var</span> arr = s.split(<span class="hljs-string">''</span>);  arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;    <span class="hljs-comment">// 当前栈顶部元素</span>    <span class="hljs-keyword">var</span> stackTop = stack[stack.length - <span class="hljs-number">1</span>];    <span class="hljs-keyword">if</span> ((stackTop === <span class="hljs-string">'('</span> &amp;&amp; item === <span class="hljs-string">')'</span>) || (stackTop === <span class="hljs-string">'&#123;'</span> &amp;&amp; item === <span class="hljs-string">'&#125;'</span>) || (stackTop === <span class="hljs-string">'['</span> &amp;&amp; item === <span class="hljs-string">']'</span>)) &#123;      stack.pop();    &#125; <span class="hljs-keyword">else</span> &#123;      stack.push(item);    &#125;  &#125;);  <span class="hljs-keyword">return</span> stack.length === <span class="hljs-number">0</span>;&#125;;</code></pre><h1 id="深度优先搜索算法"><a href="#深度优先搜索算法" class="headerlink" title="深度优先搜索算法"></a>深度优先搜索算法</h1><h2 id="leetCode-1"><a href="#leetCode-1" class="headerlink" title="leetCode"></a>leetCode</h2><p>题目编号：200<br><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a></p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;character[][]&#125;</span> <span class="hljs-variable">grid</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> numIslands = <span class="hljs-function">(<span class="hljs-params">grid</span>) =&gt;</span> &#123;  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;      <span class="hljs-keyword">if</span> (grid[i][j] === <span class="hljs-string">'1'</span>) &#123;        count++        turnZero(i, j, grid)      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> count&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">turnZero</span>(<span class="hljs-params">i, j, grid</span>) </span>&#123;  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= grid.length || j &lt; <span class="hljs-number">0</span> || j &gt;= grid[<span class="hljs-number">0</span>].length || grid[i][j] === <span class="hljs-string">'0'</span>) <span class="hljs-keyword">return</span>  grid[i][j] = <span class="hljs-string">'0'</span>  turnZero(i, j + <span class="hljs-number">1</span>, grid)  turnZero(i, j - <span class="hljs-number">1</span>, grid)  turnZero(i + <span class="hljs-number">1</span>, j, grid)  turnZero(i - <span class="hljs-number">1</span>, j, grid)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetCode刷题（一）循环队列和广度优先搜索算法</title>
    <link href="/blog/2019/09/10/20190910/"/>
    <url>/blog/2019/09/10/20190910/</url>
    
    <content type="html"><![CDATA[<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><h2 id="leetCode"><a href="#leetCode" class="headerlink" title="leetCode"></a>leetCode</h2><p>题目编号：622<br><a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">设计循环队列</a></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>(1) 使用双指针 head 和 tail 标记开头循环队列的头和尾</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initialize your data structure here. Set the size of the queue to be k.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> MyCircularQueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">k</span>) </span>&#123;  <span class="hljs-keyword">this</span>.k = k;  <span class="hljs-keyword">this</span>.tail = <span class="hljs-number">-1</span>;  <span class="hljs-keyword">this</span>.head = <span class="hljs-number">-1</span>;  <span class="hljs-keyword">this</span>.queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(k);&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment">* Insert an element into the circular queue. Return true if the operation is successful. </span><span class="hljs-comment">* <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">value</span></span></span><span class="hljs-comment">* <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment">*/</span>MyCircularQueue.prototype.enQueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isFull()) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">this</span>.tail = ++<span class="hljs-keyword">this</span>.tail % <span class="hljs-keyword">this</span>.k;    <span class="hljs-keyword">this</span>.queue[<span class="hljs-keyword">this</span>.tail] = value;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.head === <span class="hljs-number">-1</span>) <span class="hljs-keyword">this</span>.head++;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment">* Delete an element from the circular queue. Return true if the operation is successful.</span><span class="hljs-comment">* <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment">*/</span>MyCircularQueue.prototype.deQueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tail === <span class="hljs-number">-1</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">this</span>.queue[<span class="hljs-keyword">this</span>.head] = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">this</span>.head = ++<span class="hljs-keyword">this</span>.head % <span class="hljs-keyword">this</span>.k;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.head &gt;= <span class="hljs-keyword">this</span>.tail) &#123;      <span class="hljs-keyword">this</span>.head = <span class="hljs-number">-1</span>;      <span class="hljs-keyword">this</span>.tail = <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment">* Get the front item from the queue.</span><span class="hljs-comment">* <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment">*/</span>MyCircularQueue.prototype.Front = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.queue[<span class="hljs-keyword">this</span>.head] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-keyword">this</span>.queue[<span class="hljs-keyword">this</span>.head] : <span class="hljs-number">-1</span>;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment">* Get the last item from the queue.</span><span class="hljs-comment">* <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment">*/</span>MyCircularQueue.prototype.Rear = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.queue[<span class="hljs-keyword">this</span>.tail] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-keyword">this</span>.queue[<span class="hljs-keyword">this</span>.tail] : <span class="hljs-number">-1</span>;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment">* Checks whether the circular queue is empty or not.</span><span class="hljs-comment">* <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment">*/</span>MyCircularQueue.prototype.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tail === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.head === <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment">* Checks whether the circular queue is full or not.</span><span class="hljs-comment">* <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment">*/</span>MyCircularQueue.prototype.isFull = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>.tail + <span class="hljs-number">1</span>) % <span class="hljs-keyword">this</span>.k === <span class="hljs-keyword">this</span>.head) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;&#125;;</code></pre><p>(2) 合理使用数组的 push() 和 shift() 方法，虽然有些投机取巧，但是很简便。</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Initialize your data structure here. Set the size of the queue to be k.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> MyCircularQueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">k</span>) </span>&#123;  <span class="hljs-keyword">this</span>.maxLen = k;  <span class="hljs-keyword">this</span>.arr = [];&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Insert an element into the circular queue. Return true if the operation is successful. </span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">value</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span>MyCircularQueue.prototype.enQueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.arr.push(value), <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Delete an element from the circular queue. Return true if the operation is successful.</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span>MyCircularQueue.prototype.deQueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.arr.shift(), <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Get the front item from the queue.</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span>MyCircularQueue.prototype.Front = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.arr[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Get the last item from the queue.</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span>MyCircularQueue.prototype.Rear = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.arr[<span class="hljs-keyword">this</span>.arr.length - <span class="hljs-number">1</span>];&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Checks whether the circular queue is empty or not.</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span>MyCircularQueue.prototype.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.arr.length === <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Checks whether the circular queue is full or not.</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span>MyCircularQueue.prototype.isFull = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.arr.length === <span class="hljs-keyword">this</span>.maxLen;&#125;;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>需要清楚 <code>arr[this.head++]</code> 和  <code>arr[++this.head]</code> 的运算符优先级；</li><li>对于代码关键判断相关逻辑，<strong>检查队列是空还是满</strong>需要考虑的测试边界情况要更多一些，例：这个数组的元素有0个、1个或者2个的情况，检查队列是满还是空是否还可靠？关键的判断逻辑应该保证其健壮，写这一部分的代码，需要多花一些时间。</li></ol><h1 id="广度优先搜索算法"><a href="#广度优先搜索算法" class="headerlink" title="广度优先搜索算法"></a>广度优先搜索算法</h1><h2 id="leetCode-1"><a href="#leetCode-1" class="headerlink" title="leetCode"></a>leetCode</h2><p>题目编号：200<br><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a></p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numIslands = <span class="hljs-function">(<span class="hljs-params">grid</span>) =&gt;</span> &#123;  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> queue = []  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;      <span class="hljs-keyword">if</span> (grid[i][j] === <span class="hljs-string">'1'</span>) &#123;        count++        grid[i][j] = <span class="hljs-string">'0'</span> <span class="hljs-comment">// 做标记，避免重复遍历</span>        queue.push([i, j])        infect(queue, grid)      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> count&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">infect</span>(<span class="hljs-params">queue, grid</span>) </span>&#123;  <span class="hljs-keyword">const</span> dirs = [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>]]  <span class="hljs-keyword">while</span> (queue.length) &#123;    <span class="hljs-keyword">const</span> cur = queue.shift()    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dir <span class="hljs-keyword">of</span> dirs) &#123;      <span class="hljs-keyword">const</span> x = cur[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>]      <span class="hljs-keyword">const</span> y = cur[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>]      <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= grid.length || y &lt; <span class="hljs-number">0</span> || y &gt;= grid[<span class="hljs-number">0</span>].length || grid[x][y] !== <span class="hljs-string">'1'</span>) &#123;        <span class="hljs-keyword">continue</span>      &#125;      grid[x][y] = <span class="hljs-string">'0'</span>      queue.push([x, y])    &#125;  &#125;&#125;</code></pre><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>数组上的每个<code>&#39;1&#39;</code>只能属于一块岛屿，所以说被搜索到了之后可以尽管将其变为<code>&#39;0&#39;</code>;</li><li>每次执行完一次<code>infect()</code> ，相当于找到了一块岛屿；</li><li>BFS通常搭配队列数据结构来进行实现。</li></ol>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你必须要明白的代理那些事儿</title>
    <link href="/blog/2019/06/29/20190629/"/>
    <url>/blog/2019/06/29/20190629/</url>
    
    <content type="html"><![CDATA[<h2 id="代理技术如何实现"><a href="#代理技术如何实现" class="headerlink" title="代理技术如何实现"></a>代理技术如何实现</h2><p>一般实现代理技术的方式就是<strong>在服务器上安装代理服务软件</strong>，让其成为一个代理服务器，从而实现代理技术。<br>常用的代理技术分为<code>正向代理</code>、<code>反向代理</code>和<code>透明代理</code>。</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>一般情况下，如果没有特别说明，代理技术默认说的是正向代理技术。关于正向代理的概念如下：  </p><p><code>正向代理</code>是一个位于客户端【用户A】和原始服务器(origin server)【服务器B】之间的服务器【代理服务器Z】，为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标(服务器B)，然后代理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端需要设置正向代理服务器，<strong>当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口，</strong>才能使用正向代理。如下图所示：<br><img src="/blog/img/20190629/1.png" srcset="/blog/img/loading.gif" alt="正向代理.png"></p><p>从上面的概念中，我们看出，文中所谓的<code>正向代理</code>就是<strong>代理服务器替代访问方【用户A】去访问目标服务器【服务器B】</strong>。很好的体现了正向代理的应用，其中之一就是科学上网，当然还有前端常用的抓包工具<code>Whistle</code>。</p><p><code>Whistle</code>其实就是将开发用的PC变为代理服务器，当移动端设备设置好代理用的PC的<code>IP</code>和<code>代理服务端口号</code>之后，移动端设备所有的请求和服务端响应的数据，都要经过<code>Whistle代理服务</code>，因此前端开发者们，可以在PC上观察接口的响应情况。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><code>反向代理</code>正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。<br><img src="/blog/img/20190629/2.png" srcset="/blog/img/loading.gif" alt="反向代理.png"><br><strong>那反向代理的作用是什么呢？主要有以下两个方面：</strong><br>1、保护和隐藏原始服务器；<br>2、负载均衡<br><img src="/blog/img/20190629/3.png" srcset="/blog/img/loading.gif" alt="负载均衡.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、正向代理需要客户端进行配置（配置代理服务器的ip和端口），反向代理需要服务端进行配置；<br>2、正向代理，对于原始服务器来说，不知道请求的真正用户是谁；<br>3、反向代理，对于用户来说，不知道原始服务器到底隐藏在哪里。</p><hr>**以上内容其实对一位前端开发来讲，应该已经够了，以下内容是属于拓展，可以适当了解**## 什么是“肉鸡”？通过前面的内容，我们可以知道正向代理，代理服务器可以替用户发出请求，从而隐藏了真实用户的信息，“肉鸡”指的就是那些**完全被用户操控的代理服务器，达到了隐藏访问者行踪的目的**![“肉鸡”百度词条.png](/blog/img/20190629/4.png)<h2 id="加速访问"><a href="#加速访问" class="headerlink" title="加速访问"></a>加速访问</h2><p>假设用户A到服务器B，经过R1路由器和R2路由器，而R1到R2路由器的链路是一个低带宽链路。而用户A到<code>代理服务器Z</code>，从<code>代理服务器Z</code>到服务器B都是高带宽链路。那么很显然就可以加速访问服务器B了。</p><h2 id="Cache作用"><a href="#Cache作用" class="headerlink" title="Cache作用"></a>Cache作用</h2><p>Cache（缓存）技术和代理服务技术是紧密联系的（不光是正向代理，反向代理也使用了Cache（缓存）技术。<br>如果在用户A访问服务器B某数据J之前，已经有人通过代理服务器Z访问过服务器B上得数据J，那么代理服务器Z会把数据J保存一段时间，如果有人正好取该数据J，那么代理服务器Z不再访问服务器B，而把缓存的数据J直接发给用户A。<br>这一技术在Cache中术语就叫Cache命中。如果有更多的像用户A的用户来访问代理服务器Z，那么这些用户都可以直接从代理服务器Z中取得数据J，而不用千里迢迢的去服务器B下载数据。<br><code>反向代理服务器</code>像正向代理服务器一样拥有Cache的作用，它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。<br><strong>这正是CDN技术的核心。</strong><br><img src="/blog/img/20190629/5.png" srcset="/blog/img/loading.gif" alt="反向代理.png"></p><p>本文参考来自：<a href="https://blog.51cto.com/z00w00/1031287" target="_blank" rel="noopener">https://blog.51cto.com/z00w00/1031287</a><br>有兴趣的朋友可以去阅读原文～</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2019前端面试题汇总（一年经验)</title>
    <link href="/blog/2019/05/26/20190526/"/>
    <url>/blog/2019/05/26/20190526/</url>
    
    <content type="html"><![CDATA[<h3 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h3><p>跳槽是为了得到更高的薪酬，或者为了寻找更具发展空间的公司一种常见的行为。我也于今年完成了一次跳槽，自然也有很多的感悟，作成本文供大家参考。<br> 本文主要分成两个部分，一部分是我自己整理的面试大纲，另外一部分是面试官考察的问题。</p><h3 id="面试大纲"><a href="#面试大纲" class="headerlink" title="面试大纲"></a>面试大纲</h3><blockquote><p>关于面试大纲，我认为每个人都是千差万别的。因为面试官都是对简历所写的项目经验进行深挖或者对你所掌握的基本技能进行考察。<br>我在简历上写的技能点包含了<code>HTML</code>/<code>CSS</code>/<code>JavaScript</code>/<code>ES6</code>/<code>HTTP协议</code>/<code>Vue</code>/<code>微信小程序</code>/<code>Node</code>/<code>Express</code>/<code>MySQL</code>/ <code>面向对象</code>/<code>设计模式</code><br>根据以上，整理出面试大纲</p></blockquote><h4 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h4><h5 id="lt-li-gt-标签之间有空格怎么处理？"><a href="#lt-li-gt-标签之间有空格怎么处理？" class="headerlink" title="&lt;li&gt;标签之间有空格怎么处理？"></a>&lt;li&gt;标签之间有空格怎么处理？</h5><p>原因：行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0或者将&lt;li&gt;标签写在一排，就没有空格了。</p><h4 id="二、CSS"><a href="#二、CSS" class="headerlink" title="二、CSS"></a>二、CSS</h4><h5 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h5><ol><li>支持rgba和透明度</li><li>支持媒体查询</li><li>支持自定义字体</li><li>对长的不可分割单词换行<code>word-wrap：break-word;</code></li><li>文字阴影<code>text-shadow: 5px 5px 5px #ff0000;</code></li><li>盒阴影<code>box-shadow: 10px 10px 5px #888888</code></li><li>支持圆角<code>border-radius: 50%;</code></li><li>边框图片<code>border-image: url(border.png) 30 30 round</code><h5 id="CSS优先级如何计算？"><a href="#CSS优先级如何计算？" class="headerlink" title="CSS优先级如何计算？"></a>CSS优先级如何计算？</h5></li></ol><ul><li>元素和伪元素：1</li><li>类选择器、属性选择器或伪类：10</li><li>id选择符：100</li><li>内联样式：1000</li></ul><ol><li>!important声明的样式优先级最高，如果冲突再进行计算。</li><li>继承得到的样式的优先级最低。</li><li>如果优先级相同，则选择最后出现的样式。</li></ol><h5 id="清除浮动的几种方式和各自的优缺点"><a href="#清除浮动的几种方式和各自的优缺点" class="headerlink" title="清除浮动的几种方式和各自的优缺点"></a>清除浮动的几种方式和各自的优缺点</h5><ol><li>添加空div，使用<code>clear: both;</code>缺点：进行清除浮动；会添加很多无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦；</li><li>父元素使用<code>overflow: hidden;</code>缺点：不能配合<code>position</code>一起使用，超出的部分会被隐藏；</li><li>父元素使用<code>overflow: auto;</code>缺点：超出部分会出现滚动条；</li><li>父级定义高度</li><li>推荐使用的方法：父级div定义伪类:after和zoom<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-class">.clearfloat</span> &#123;</span>    *zoom: 1;&#125;<span class="css"><span class="hljs-selector-class">.clearfloat</span><span class="hljs-selector-pseudo">:after</span> &#123;</span>    content: "";    height: 0;    display: block;    clear: both;    visibility: hidden;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-comment">&lt;!-- *是为了兼容低版本IE7浏览器 zoom是ie属性，设置缩放比例 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box clearfloat"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h5 id="如何水平居中一个浮动元素？"><a href="#如何水平居中一个浮动元素？" class="headerlink" title="如何水平居中一个浮动元素？"></a>如何水平居中一个浮动元素？</h5><pre><code class="hljs scss"><span class="hljs-selector-id">#test</span> &#123;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">background-color</span>: green;  &lt;!-- 三行代码缺一不可 --&gt;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"test"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre><h5 id="如何水平居中一个浮动元素？-1"><a href="#如何水平居中一个浮动元素？-1" class="headerlink" title="如何水平居中一个浮动元素？"></a>如何水平居中一个浮动元素？</h5><pre><code class="hljs scss"><span class="hljs-selector-id">#test</span> &#123;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">background-color</span>: green;  &lt;!-- 三行代码缺一不可 --&gt;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"test"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre><h5 id="利用CSS画三角形"><a href="#利用CSS画三角形" class="headerlink" title="利用CSS画三角形"></a>利用CSS画三角形</h5><pre><code class="hljs css"><span class="hljs-selector-id">#triangle</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">40px</span> solid transparent;  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">40px</span> solid transparent;  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">40px</span> solid transparent;  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">40px</span> solid greenyellow;&#125;</code></pre><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"triangle"</span>&gt;&lt;<span class="hljs-keyword">div</span>&gt;</code></pre><h5 id="display-none-和-visibility-hidden-的区别？"><a href="#display-none-和-visibility-hidden-的区别？" class="headerlink" title="display: none; 和 visibility: hidden; 的区别？"></a><code>display: none;</code> 和 <code>visibility: hidden;</code> 的区别？</h5></li><li><code>display：none;</code> 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</li><li><code>visibility：hidden;</code> 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</li></ol><h5 id="position-和-float-值相互叠加会发生什么？"><a href="#position-和-float-值相互叠加会发生什么？" class="headerlink" title="position 和 float 值相互叠加会发生什么？"></a><code>position</code> 和 <code>float</code> 值相互叠加会发生什么？</h5><p><code>position：absolute/fixed;</code> 优先级最高，有他们在时，<code>float</code>不起作用，<code>display</code>值需要调整。</p><h5 id="对BFC规范-块级格式化上下文：block-formatting-context-的理解？"><a href="#对BFC规范-块级格式化上下文：block-formatting-context-的理解？" class="headerlink" title="对BFC规范(块级格式化上下文：block formatting context)的理解？"></a>对BFC规范(块级格式化上下文：block formatting context)的理解？</h5><p>BFC规定了内部的Block Box如何布局。<br>定位方案：</p><ol><li>内部的Box会在垂直方向上一个接一个放置。</li><li>Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。</li><li>每个元素的margin box 的左边，与包含块border box的左边相接触。</li><li>BFC的区域不会与float box重叠。</li><li>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</li><li>计算BFC的高度时，浮动元素也会参与计算。</li></ol><p>满足下列条件之一就可触发BFC</p><ol><li><p>根元素，即html</p></li><li><p>float的值不为none（默认）</p></li><li><p>overflow的值不为visible（默认）</p></li><li><p>display的值为inline-block、table-cell、table-caption</p></li><li><p>position的值为absolute或fixed</p><h5 id="为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"><a href="#为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？" class="headerlink" title="为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"></a>为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</h5><p>浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。<br>浮动带来的问题：</p></li><li><p>父元素的高度无法被撑开，影响与父元素同级的元素</p></li><li><p>与浮动元素同级的非浮动元素（内联元素）会跟随其后</p></li><li><p>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。</p></li></ol><p>清除浮动的方式：</p><ol><li>父级div定义height</li><li>最后一个浮动元素后加空div标签 并添加样式clear:both。</li><li>包含浮动元素的父标签添加样式overflow为hidden或auto。</li><li>父级div定义zoom<h5 id="after和-after的区别是什么？"><a href="#after和-after的区别是什么？" class="headerlink" title=":after和::after的区别是什么？"></a><code>:after</code>和<code>::after</code>的区别是什么？</h5></li><li>在CSS3的规范里<code>:</code>表示伪类，<code>::</code>表示伪元素</li><li><code>:after</code>在CSS2.1的规范中，表示伪元素，随着WEB的发展，在CSS3的规范中，伪元素的语法被修改成使用双冒号，成为<code>::after</code><h5 id="实现一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度"><a href="#实现一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度" class="headerlink" title="实现一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度"></a>实现一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</h5><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;&#125;<span class="hljs-selector-id">#box</span> &#123;  <span class="hljs-attribute">position</span>: relative;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;  <span class="hljs-attribute">background-color</span>: beige;&#125;<span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.block-1</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">background-color</span>: rosybrown;&#125;<span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.block-2</span> &#123;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">top</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;  <span class="hljs-attribute">background-color</span>: red;&#125;</code></pre><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"box"</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"block-1"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"block-2"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre><h4 id="三、JavaScript"><a href="#三、JavaScript" class="headerlink" title="三、JavaScript"></a>三、JavaScript</h4><h5 id="简单说说继承的方式和优缺点？"><a href="#简单说说继承的方式和优缺点？" class="headerlink" title="简单说说继承的方式和优缺点？"></a>简单说说继承的方式和优缺点？</h5><h6 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h6><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>&#123;     <span class="hljs-keyword">this</span>.name = name;&#125;Parent.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent name:'</span>, <span class="hljs-keyword">this</span>.name);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;&#125;Child.prototype = <span class="hljs-keyword">new</span> Parent(<span class="hljs-string">'father'</span>);Child.prototype.constructor = Child;Child.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child name:'</span>, <span class="hljs-keyword">this</span>.name);&#125;<span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">'son'</span>);child.sayName();    <span class="hljs-comment">// child name: son</span><span class="hljs-comment">// 这种方法存在两个缺陷：</span><span class="hljs-comment">// 1.子类型无法给超类型传递参数，在面向对象的继承中，我们总希望通过 var child = new Child('son', 'father'); 让子类去调用父类的构造器来完成继承。而不是通过像这样 new Parent('father') 去调用父类。</span><span class="hljs-comment">// 2.Child.prototype.sayName 必须写在 Child.prototype = new Parent('father') 之后，不然就会被覆盖掉。</span></code></pre><h6 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h6><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>&#123;     <span class="hljs-keyword">this</span>.name = name;&#125;Parent.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent name:'</span>, <span class="hljs-keyword">this</span>.name);&#125;Parent.prototype.doSomthing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent do something!'</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name, parentName</span>) </span>&#123;    Parent.call(<span class="hljs-keyword">this</span>, parentName);    <span class="hljs-keyword">this</span>.name = name;&#125;Child.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child name:'</span>, <span class="hljs-keyword">this</span>.name);&#125;<span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">'son'</span>);child.sayName();      <span class="hljs-comment">// child name: son</span>child.doSomthing();   <span class="hljs-comment">// TypeError: child.doSomthing is not a function</span><span class="hljs-comment">// 解决了原型链继承带来的问题</span><span class="hljs-comment">// 但存在缺陷：每次创建一个 Child 实例对象时候都需要执行一遍 Parent 函数，无法复用一些公用函数。</span></code></pre><h6 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h6><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>&#123;     <span class="hljs-keyword">this</span>.name = name;&#125;Parent.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent name:'</span>, <span class="hljs-keyword">this</span>.name);&#125;Parent.prototype.doSomething = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent do something!'</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name, parentName</span>) </span>&#123;    Parent.call(<span class="hljs-keyword">this</span>, parentName);      <span class="hljs-comment">// 第二次调用</span>    <span class="hljs-keyword">this</span>.name = name;&#125;Child.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child name:'</span>, <span class="hljs-keyword">this</span>.name);&#125;Child.prototype = <span class="hljs-keyword">new</span> Parent();         <span class="hljs-comment">// 第一次调用</span>Child.prototype.construtor = Child;<span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">'son'</span>);child.sayName();      child.doSomething(); <span class="hljs-comment">// 第一次调用构造函数显然是没有必要的，因为第一次调用构造函数时候不需要函数内部的那些实例属性，这么写只是想获得其原型上的方法罢了</span><span class="hljs-comment">// 下面的寄生组合式继承解决了这个问题</span></code></pre><h6 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h6><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;&#125;Parent.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent name:'</span>, <span class="hljs-keyword">this</span>.name);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name, parentName</span>) </span>&#123;    Parent.call(<span class="hljs-keyword">this</span>, parentName);      <span class="hljs-keyword">this</span>.name = name;    &#125;Child.prototype = <span class="hljs-built_in">Object</span>.create(Parent.prototype);   <span class="hljs-comment">//修改</span>Child.prototype.construtor = Child;Child.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child name:'</span>, <span class="hljs-keyword">this</span>.name);&#125;<span class="hljs-keyword">var</span> parent = <span class="hljs-keyword">new</span> Parent(<span class="hljs-string">'father'</span>);parent.sayName();      <span class="hljs-comment">// parent name: father</span><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">'son'</span>, <span class="hljs-string">'father'</span>);child.sayName();       <span class="hljs-comment">// child name: son</span></code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// tips:</span><span class="hljs-comment">/*</span><span class="hljs-comment">  Object.create(proto, [propertiesObject])</span><span class="hljs-comment">  Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__</span><span class="hljs-comment">  </span><span class="hljs-comment">  proto</span><span class="hljs-comment">    新创建对象的原型对象。</span><span class="hljs-comment">  propertiesObject 可选。</span><span class="hljs-comment">    如果没有指定为undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。</span><span class="hljs-comment">  </span><span class="hljs-comment">*/</span></code></pre><h5 id="谈谈JS中的this"><a href="#谈谈JS中的this" class="headerlink" title="谈谈JS中的this"></a>谈谈JS中的<code>this</code></h5></li><li><code>this</code>是在执行上下文创建时确定的一个在执行过程中不可更改的变量</li><li><code>this</code>只在函数调用阶段确定，也就是执行上下文创建的阶段进行赋值，保存在变量对象中。<blockquote><p><strong>执行上下文</strong>，就是JavaScript引擎在执行一段代码之前将代码内部会用到的一些<code>变量</code>、<code>函数</code>、<code>this</code>提前声明然后保存在变量对象中的过程。</p></blockquote><h5 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h5></li><li>()括号 .成员访问</li><li>()函数调用 new</li><li>++ – !</li><li>*  %</li><li>+ -</li><li>&gt;= &lt;= &gt; &lt;</li><li>== !==</li><li>&amp; ^ | 位运算符</li><li>&amp;&amp; || 逻辑运算符</li><li>a ? x : y 条件运算符</li><li>= op = 运算赋值<pre><code class="hljs javascript"><span class="hljs-comment">// 本题的涉及考点主要还是运算符的优先级</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;  getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>&#125;Foo.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)&#125;Foo.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)&#125;<span class="hljs-keyword">var</span> getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)&#125;<span class="hljs-comment">// 写出以下函数的执行结果</span>Foo.getName()            <span class="hljs-comment">// 2</span>getName()                <span class="hljs-comment">// 4</span>Foo().getName()          <span class="hljs-comment">// 1  </span>getName()                <span class="hljs-comment">// 1</span><span class="hljs-keyword">new</span> Foo.getName()        <span class="hljs-comment">// 2</span><span class="hljs-comment">// new (Foo.getName)()</span><span class="hljs-keyword">new</span> Foo().getName()      <span class="hljs-comment">// 3</span><span class="hljs-comment">// (new Foo()).getName()</span><span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> Foo().getName()  <span class="hljs-comment">// 3</span><span class="hljs-comment">// new((new Foo()).getName)()</span></code></pre><h5 id="简单聊一聊包装对象？"><a href="#简单聊一聊包装对象？" class="headerlink" title="简单聊一聊包装对象？"></a>简单聊一聊包装对象？</h5><code>引用类型</code>和<code>包装对象</code>的区别在于<strong>生存期</strong><br>引用类型所创建的对象会一直存在于堆内存中，而基本包装对象只存在于一瞬间<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">'hello'</span>;str.number = <span class="hljs-number">10</span>;   <span class="hljs-comment">//假设我们想给字符串添加一个属性number ，后台会有如下步骤</span><span class="hljs-comment">/*</span><span class="hljs-comment">  var str = new String('hello'); // 1 找到对应的包装对象类型，然后通过包装对象创建出一个和基本类型值相同的对象</span><span class="hljs-comment">  str.number = 10; // 2 通过这个对象调用包装对象下的方法 但结果并没有被任何东西保存</span><span class="hljs-comment">  str =null; // 3 这个对象又被销毁</span><span class="hljs-comment">*/</span>alert(str.number); <span class="hljs-comment">//undefined  当执行到这一句的时候，因为基本类型本来没有属性，后台又会重新重复上面的步骤</span><span class="hljs-comment">/*</span><span class="hljs-comment"> var str = new String('hello'); // 1 找到基本包装对象，然后又新开辟一个内存，创建一个值为hello对象</span><span class="hljs-comment"> str.number = undefined   // 2 因为包装对象下面没有number这个属性，所以又会重新添加，因为没有值，所以值是未定 ;然后弹出结果</span><span class="hljs-comment"> str =null; // 3 这个对象又被销毁</span><span class="hljs-comment">*/</span></code></pre><h5 id="instanceof-和-typeof"><a href="#instanceof-和-typeof" class="headerlink" title="instanceof 和 typeof"></a>instanceof 和 typeof</h5><code>instanceof</code>运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置（Instanceof 的使用规则是： <code>A instanceof B</code> A沿着proto这条线来找，同时B沿着prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。）<h5 id="函数-变量提升"><a href="#函数-变量提升" class="headerlink" title="函数/变量提升"></a>函数/变量提升</h5><pre><code class="hljs javascript"><span class="hljs-comment">// 1、函数提升优先级高于变量提升</span><span class="hljs-comment">// 2、表达式可以修改提升后变量的值</span>test() <span class="hljs-comment">// 2</span><span class="hljs-keyword">var</span> test = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)&#125;test() <span class="hljs-comment">// 1</span>  alert(a);<span class="hljs-keyword">var</span> a=<span class="hljs-number">1</span>;alert(a); <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;alert(<span class="hljs-number">2</span>)&#125;;alert(a);<span class="hljs-keyword">var</span> a=<span class="hljs-number">3</span>;alert(a);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;alert(<span class="hljs-number">4</span>)&#125;;alert(a);a();<span class="hljs-comment">// function a() &#123;alert (4)&#125;; </span><span class="hljs-comment">// 1</span><span class="hljs-comment">// 1</span><span class="hljs-comment">// 3</span><span class="hljs-comment">// 3</span><span class="hljs-comment">// 报错</span></code></pre><h5 id="new-操作符都干了些什么？"><a href="#new-操作符都干了些什么？" class="headerlink" title="new 操作符都干了些什么？"></a>new 操作符都干了些什么？</h5><pre><code class="hljs javascript"><span class="hljs-comment">// new共经历了四个阶段</span><span class="hljs-comment">// 1、创建一个空对象</span><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<span class="hljs-comment">// 2、设置原型链</span>obj.__proto__ = Func.prototype<span class="hljs-comment">// 3、让Func中的this指向obj，并执行Func的函数体</span><span class="hljs-keyword">var</span> result = Func.call(obj)<span class="hljs-comment">// 4、判断Func的返回值类型</span><span class="hljs-comment">// 如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象</span><span class="hljs-comment">// (tip: 构造函数默认 return this，不用写)</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'object'</span>) &#123;    <span class="hljs-keyword">return</span> result&#125; eles &#123;    <span class="hljs-keyword">return</span> obj&#125;</code></pre><h4 id="四、Vue"><a href="#四、Vue" class="headerlink" title="四、Vue"></a>四、Vue</h4><h5 id="对MVVM的理解"><a href="#对MVVM的理解" class="headerlink" title="对MVVM的理解"></a>对MVVM的理解</h5>MVVM分为Model、View、ViewModel三者<br></li></ol><p><code>Model</code> 代表数据模型，数据和业务逻辑都在Model层中定义；<br><code>View</code> 代表UI视图，负责数据的展示；<br><code>ViewModel</code> 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；</p><p>Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。<br>这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom</p><h5 id="Vue的双向数据绑定是如何实现的？"><a href="#Vue的双向数据绑定是如何实现的？" class="headerlink" title="Vue的双向数据绑定是如何实现的？"></a>Vue的双向数据绑定是如何实现的？</h5><p>简单来说就是使用<code>数据劫持</code>和<code>发布订阅的设计模式</code>实现的</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>MVVM双向数据绑定<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vue</span> </span>&#123;</span><span class="javascript">      <span class="hljs-keyword">constructor</span>(options) &#123;</span><span class="actionscript">        <span class="hljs-keyword">this</span>.options = options</span><span class="actionscript">        <span class="hljs-keyword">this</span>.$data = options.data</span><span class="javascript">        <span class="hljs-keyword">this</span>.$el = <span class="hljs-built_in">document</span>.querySelector(options.el)</span><span class="actionscript">        <span class="hljs-keyword">this</span>._directives = &#123;&#125;;</span><span class="actionscript">        <span class="hljs-comment">// 数据劫持</span></span><span class="actionscript">        <span class="hljs-keyword">this</span>.Observer(<span class="hljs-keyword">this</span>.$data)</span><span class="actionscript">        <span class="hljs-comment">// 解析指令</span></span><span class="actionscript">        <span class="hljs-keyword">this</span>.Compile(<span class="hljs-keyword">this</span>.$el)</span>      &#125;      Observer(data) &#123;<span class="javascript">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> data) &#123;</span><span class="actionscript">          <span class="hljs-keyword">this</span>._directives[key] = []</span><span class="javascript">          <span class="hljs-keyword">let</span> val = data[key]</span><span class="javascript">          <span class="hljs-keyword">let</span> _obj = <span class="hljs-keyword">this</span>._directives[key]</span><span class="javascript">          <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>.$data, key, &#123;</span><span class="actionscript">            <span class="hljs-keyword">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;</span><span class="actionscript">              <span class="hljs-keyword">return</span> val</span>            &#125;,<span class="actionscript">            <span class="hljs-keyword">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(newVal)</span> </span>&#123;</span>              if(val !== newVal) &#123;                val = newVal<span class="javascript">                _obj.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;</span>                  item.update()                &#125;)              &#125;            &#125;          &#125;)        &#125;      &#125;      Compile(el) &#123;<span class="javascript">        <span class="hljs-keyword">let</span> nodes = el.children</span><span class="javascript">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;nodes.length; i++) &#123;</span><span class="javascript">          <span class="hljs-keyword">let</span> node = nodes[i]</span>          if(node.children.length) &#123;<span class="actionscript">            <span class="hljs-keyword">this</span>.Compile(node)</span>          &#125;<span class="actionscript">          <span class="hljs-keyword">if</span>(node.hasAttribute(<span class="hljs-string">'v-text'</span>)) &#123;</span><span class="javascript">            <span class="hljs-keyword">let</span> attrValue = node.getAttribute(<span class="hljs-string">"v-text"</span>);</span><span class="actionscript">            <span class="hljs-keyword">this</span>._directives[attrValue].push(<span class="hljs-keyword">new</span> Watch(node, <span class="hljs-keyword">this</span>, attrValue, <span class="hljs-string">"innerHTML"</span>))</span>          &#125;<span class="actionscript">          <span class="hljs-keyword">if</span>(node.hasAttribute(<span class="hljs-string">'v-model'</span>)) &#123;</span><span class="javascript">            <span class="hljs-keyword">let</span> _this = <span class="hljs-keyword">this</span></span><span class="javascript">            <span class="hljs-keyword">let</span> attrValue = node.getAttribute(<span class="hljs-string">"v-model"</span>);</span><span class="actionscript">            <span class="hljs-keyword">this</span>._directives[attrValue].push(<span class="hljs-keyword">new</span> Watch(node, <span class="hljs-keyword">this</span>, attrValue, <span class="hljs-string">"value"</span>))</span><span class="actionscript">            node.addEventListener(<span class="hljs-string">'input'</span>, (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;</span><span class="actionscript">              <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;</span>                _this.$data[attrValue] = node.value              &#125;            &#125;)())          &#125;        &#125;      &#125;    &#125;<span class="actionscript">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watch</span> </span>&#123;</span><span class="javascript">      <span class="hljs-keyword">constructor</span>(el, vm, exp, attr) &#123;</span><span class="actionscript">        <span class="hljs-keyword">this</span>.el = el</span><span class="actionscript">        <span class="hljs-keyword">this</span>.vm = vm</span><span class="actionscript">        <span class="hljs-keyword">this</span>.exp = exp</span><span class="actionscript">        <span class="hljs-keyword">this</span>.attr = attr</span><span class="actionscript">        <span class="hljs-keyword">this</span>.update()</span>      &#125;      update() &#123;<span class="actionscript">        <span class="hljs-keyword">this</span>.el[<span class="hljs-keyword">this</span>.attr] = <span class="hljs-keyword">this</span>.vm.$data[<span class="hljs-keyword">this</span>.exp]</span>      &#125;    &#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>数据双向绑定<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">"myText"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"myText"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">      el: <span class="hljs-string">'#app'</span>,</span>      data: &#123;<span class="actionscript">        myText: <span class="hljs-string">'今晚吃鸡呐，大吉大利！'</span></span>      &#125;    &#125;);  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h5 id="Vue如何监听某个属性值的变化"><a href="#Vue如何监听某个属性值的变化" class="headerlink" title="Vue如何监听某个属性值的变化"></a>Vue如何监听某个属性值的变化</h5><pre><code class="hljs javascript">watch: &#123;  <span class="hljs-string">'obj.a'</span>: &#123;    handler (newName, oldName) &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'obj.a changed'</span>)    &#125;  &#125;&#125;computed: &#123;  a1 () &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.obj.a  &#125;&#125;</code></pre><h5 id="Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决"><a href="#Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决" class="headerlink" title="Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决?"></a>Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决?</h5><p>数据已经添加，但是视图并没有刷新；<br><br>原因在于在Vue实例创建时，<code>obj.b</code>并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局api <code>Vue.$set()</code></p><pre><code class="hljs javascript">addObjB () &#123;  <span class="hljs-comment">// this.obj.b = 'obj.b'</span>  <span class="hljs-keyword">this</span>.$<span class="hljs-keyword">set</span>(this.obj, 'b', 'obj.b')  console.log(this.obj)&#125;</code></pre><h5 id="Vue组件通讯的方式"><a href="#Vue组件通讯的方式" class="headerlink" title="Vue组件通讯的方式"></a>Vue组件通讯的方式</h5><ol><li>父子组件通讯：父-&gt;子：使用props，子-&gt;父：$emit方法传递参数</li><li>使用eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件</li><li>Vuex<blockquote><p>可以去掘金找这类文章看一下，Vue组件的通讯方式达6种之多</p></blockquote></li></ol><h5 id="Vue常用的修饰符"><a href="#Vue常用的修饰符" class="headerlink" title="Vue常用的修饰符"></a>Vue常用的修饰符</h5><p><code>.prevent</code>: 提交事件不再重载页面；<br><code>.stop</code>: 阻止单击事件冒泡；<br><code>.self</code>: 当事件发生在该元素本身而不是子元素的时候会触发；<br><code>.capture</code>: 事件侦听，事件发生的时候会调用；</p><h5 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和 $router 的区别"></a>$route 和 $router 的区别</h5><p><strong>$route</strong> 是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数<br><strong>$router</strong> 是“路由实例”对象包括了路由的跳转方法，钩子函数等</p><h5 id="Vue的路由实现：hash模式-和-history模式"><a href="#Vue的路由实现：hash模式-和-history模式" class="headerlink" title="Vue的路由实现：hash模式 和 history模式"></a>Vue的路由实现：hash模式 和 history模式</h5><p><strong>hash模式：</strong> 在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；<br>特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。<br>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a href="http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回" target="_blank" rel="noopener">http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回</a> 404 错误。</p><p><strong>history模式：</strong> history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。<br>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <a href="http://www.xxx.com/items/id。后端如果缺少对" target="_blank" rel="noopener">http://www.xxx.com/items/id。后端如果缺少对</a> /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</p><h5 id="对keep-alive的了解？"><a href="#对keep-alive的了解？" class="headerlink" title="对keep-alive的了解？"></a>对keep-alive的了解？</h5><p><strong>keep-alive</strong>是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染<br>在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。</p><h5 id="delete和Vue-delete删除数组的区别？"><a href="#delete和Vue-delete删除数组的区别？" class="headerlink" title="delete和Vue.delete删除数组的区别？"></a>delete和Vue.delete删除数组的区别？</h5><p>delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变；<br>Vue.delete直接删除了数组 改变了数组的键值。</p><h5 id="如何优化SPA应用的首屏加载速度慢的问题？"><a href="#如何优化SPA应用的首屏加载速度慢的问题？" class="headerlink" title="如何优化SPA应用的首屏加载速度慢的问题？"></a>如何优化SPA应用的首屏加载速度慢的问题？</h5><ol><li>将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；</li><li>在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；</li><li>加一个首屏 loading 图，提升用户体验；</li></ol><h5 id="Vuex是什么？如何使用？哪种场景使用它？"><a href="#Vuex是什么？如何使用？哪种场景使用它？" class="headerlink" title="Vuex是什么？如何使用？哪种场景使用它？"></a>Vuex是什么？如何使用？哪种场景使用它？</h5><p>将需要读取的状态集中放在<code>store</code>中<br>改变状态的方式是提交<code>mutations</code>，这是一个同步的事务<br>异步逻辑应该封装在<code>actions</code>中</p><p><strong>state</strong> Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。<br><strong>mutations</strong> 定义的方法动态修改<code>Vuex</code>的<code>store</code>中的状态或数据。<br><strong>getters</strong> 类似<code>vue</code>的计算属性，主要用来过滤一些数据。<br><strong>action</strong> 可以理解为通过将<code>mutations</code>里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view层通过<code>store.dispath</code>来分发<code>action</code><br><strong>modules</strong> 项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理</p><h5 id="Vue等单页应用的优缺点"><a href="#Vue等单页应用的优缺点" class="headerlink" title="Vue等单页应用的优缺点"></a>Vue等单页应用的优缺点</h5><p>优点：Vue的目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件，核心是<strong>响应式系统</strong>。<br>缺点：不支持低版本浏览器，最低仅支持ie9；不利于SEO的优化，首页加载耗时相对偏长一些。</p><h4 id="五、ES6"><a href="#五、ES6" class="headerlink" title="五、ES6"></a>五、ES6</h4><h5 id="let和var的区别"><a href="#let和var的区别" class="headerlink" title="let和var的区别"></a><code>let</code>和<code>var</code>的区别</h5><ol><li>不存在变量提升</li><li>暂时性的死区<pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;  <span class="hljs-comment">// --- 死区开始 ---</span>  tmp = <span class="hljs-string">'abc'</span>; <span class="hljs-comment">// ReferenceError</span>  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// ReferenceError</span>  <span class="hljs-keyword">let</span> tmp;  <span class="hljs-comment">// --- 死区结束 ---</span>  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// undefined</span>  tmp = <span class="hljs-number">123</span>;  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// 123</span>&#125;</code></pre></li><li><code>let</code>为JavaScript新增了块级作用域<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  a[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(i);  &#125;;&#125;a[<span class="hljs-number">6</span>](); <span class="hljs-comment">// 10</span><span class="hljs-comment">// 变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i，每一次循环，变量i的值都会发生改变</span><span class="hljs-keyword">var</span> a = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  a[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(i);  &#125;;&#125;a[<span class="hljs-number">6</span>](); <span class="hljs-comment">// 6</span><span class="hljs-comment">// 变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。</span></code></pre><h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5>定义：从数组或对象中提取值，对变量进行赋值</li><li>数组的解构赋值<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">let</span> [ , , third] = [<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>, <span class="hljs-string">"baz"</span>];third <span class="hljs-comment">// "baz"</span><span class="hljs-keyword">let</span> [x, , y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];x <span class="hljs-comment">// 1</span>y <span class="hljs-comment">// 3</span><span class="hljs-keyword">let</span> [head, ...tail] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];head <span class="hljs-comment">// 1</span>tail <span class="hljs-comment">// [2, 3, 4]</span><span class="hljs-keyword">let</span> [x, y, ...z] = [<span class="hljs-string">'a'</span>];x <span class="hljs-comment">// "a"</span>y <span class="hljs-comment">// undefined</span>z <span class="hljs-comment">// []</span><span class="hljs-keyword">let</span> [x, y = <span class="hljs-number">10</span>] = [<span class="hljs-number">7</span>]</code></pre></li><li>对象的解构赋值<br><br>（tip: 数组的解构赋值对顺序有要求，而对象则没有要求，变量必须与属性同名，才能取到正确的值）<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">'aaa'</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">'bbb'</span> &#125;;foo <span class="hljs-comment">// "aaa"</span>bar <span class="hljs-comment">// "bbb"</span><span class="hljs-keyword">let</span> &#123; baz &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">'aaa'</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">'bbb'</span> &#125;;baz <span class="hljs-comment">// undefined</span><span class="hljs-keyword">var</span> &#123;x, y = <span class="hljs-number">5</span>&#125; = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;;<span class="hljs-comment">// 如果变量名与属性名不一致，必须写成下面这样。</span><span class="hljs-comment">// foo 是模式， baz 才是变量，特别要注意区分模式和变量</span><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">foo</span>: baz &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">'aaa'</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">'bbb'</span> &#125;;</code></pre></li><li>嵌套解构赋值<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;  p: [    <span class="hljs-string">'Hello'</span>,    &#123; <span class="hljs-attr">y</span>: <span class="hljs-string">'World'</span> &#125;  ]&#125;;<span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">p</span>: [x, &#123; y &#125;] &#125; = obj;x <span class="hljs-comment">// "Hello"</span>y <span class="hljs-comment">// "World"</span><span class="hljs-comment">// p 是模式，不会被复制，若想被赋值，可以写成如下形式</span><span class="hljs-keyword">let</span> &#123; p, <span class="hljs-attr">p</span>: [x, &#123; y &#125;] &#125; = obj;x <span class="hljs-comment">// "Hello"</span>y <span class="hljs-comment">// "World"</span>p <span class="hljs-comment">// ["Hello", &#123;y: "World"&#125;]</span></code></pre><h5 id="箭头函数和非箭头函数的区别"><a href="#箭头函数和非箭头函数的区别" class="headerlink" title="箭头函数和非箭头函数的区别"></a>箭头函数和非箭头函数的区别</h5></li><li>箭头函数的<code>this</code>指向在定义的时候继承自外层的第一个普通函数的<code>this</code>，若外层没有普通函数，指向的是<code>window</code></li><li>不能直接修改箭头函数的<code>this</code>指向</li><li>箭头函数的this指向全局，使用<code>arguments</code>会报未声明的错误。</li><li>箭头函数的this指向普通函数时,它的<code>argumens</code>继承于该普通函数</li><li>使用<code>new</code>调用箭头函数会报错，因为箭头函数没有<code>constructor</code></li></ol><h5 id="简单讲讲Promise"><a href="#简单讲讲Promise" class="headerlink" title="简单讲讲Promise"></a>简单讲讲Promise</h5><p><strong>Promise的特点</strong><br>状态一旦改变就再也不会发生改变了<br><strong>Promise的缺点</strong></p><ol><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消；</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部；</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ol><h5 id="如何创建Promise实例？"><a href="#如何创建Promise实例？" class="headerlink" title="如何创建Promise实例？"></a>如何创建Promise实例？</h5><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;    resolve(value);  &#125; <span class="hljs-keyword">else</span> &#123;    reject(error);  &#125;&#125;);</code></pre><h5 id="简单讲讲Promise-API"><a href="#简单讲讲Promise-API" class="headerlink" title="简单讲讲Promise API"></a>简单讲讲Promise API</h5><ul><li>Promise.resolve();<pre><code class="hljs javascript"><span class="hljs-comment">// 1. 如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">resolve</span>)</span>&#123;    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        resolve(<span class="hljs-number">123</span>);    &#125;,<span class="hljs-number">3000</span>);&#125;<span class="hljs-keyword">let</span> p0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(fn);<span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(p0);<span class="hljs-comment">// 返回为true，返回的 Promise 即是 入参的 Promise 对象。</span><span class="hljs-built_in">console</span>.log(p0 === p1);<span class="hljs-comment">//2. 如果这个值是个 thenable（thenable对象指的是具有then方法的对象），返回的 Promise 对象会“跟随”这个 thenable 的对象，采用它的最终状态（指 resolved/rejected/pending/settled）</span><span class="hljs-keyword">let</span> promise = <span class="hljs-built_in">Promise</span>.resolve($.ajax(<span class="hljs-string">'/test/test.json'</span>));<span class="hljs-comment">// =&gt; promise对象</span>promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;   <span class="hljs-built_in">console</span>.log(value);&#125;);</code></pre></li><li>Promise.reject();</li><li>Promise.race<pre><code class="hljs javascript"><span class="hljs-comment">// 类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise</span><span class="hljs-comment">// 任务的结果，不管这个 Promise 结果是成功还是失败。 。</span></code></pre></li><li>Promise.all<pre><code class="hljs javascript"><span class="hljs-comment">// 类方法，多个 Promise 任务同时执行。</span><span class="hljs-comment">// 如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。</span><span class="hljs-comment">// 如果有一个 Promise 任务 rejected，则只返回 rejected 任务的结果。</span><span class="hljs-keyword">const</span> promises = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>&#123;  <span class="hljs-keyword">return</span> getJSON(<span class="hljs-string">'/post/'</span> + id + <span class="hljs-string">".json"</span>);&#125;);<span class="hljs-built_in">Promise</span>.all(promises).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">posts</span>) </span>&#123;  <span class="hljs-comment">// ...</span>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)</span>&#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></li><li>Promise.prototype.then()</li><li>Promise.prototype.catch() 该方法可以捕获到then链上发生的任何一个错误</li><li>Promise.prototype.finally() 该方法用于指定不管 <code>Promise</code> 对象最后状态如何，都会执行的操作<pre><code class="hljs javascript">promise.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;···&#125;).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;···&#125;).finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-comment">// finally方法的回调函数不接受任何参数，这意味着没有办法知道，</span>    <span class="hljs-comment">//前面的 Promise 状态到底是fulfilled还是rejected。这表明，</span>    <span class="hljs-comment">// finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</span>&#125;);</code></pre>关于<code>Promise</code>，不同面试官考察的深度因人而异，反正做好手写实现<code>Promise</code>的准备即可<h4 id="六、微信小程序"><a href="#六、微信小程序" class="headerlink" title="六、微信小程序"></a>六、微信小程序</h4><h5 id="简述微信小程序原理"><a href="#简述微信小程序原理" class="headerlink" title="简述微信小程序原理"></a>简述微信小程序原理</h5></li></ul><ol><li>小程序本质就是一个单页应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口；</li><li>功能可分为渲染层<code>webview</code>和逻辑层<code>appService</code>两个部分；<br><code>webview</code>用来展现UI，<code>appService</code>有来处理业务逻辑、数据及接口调用；<br>两个部分在两个进程中运行，通过系统层<code>JSBridge</code>实现通信，实现UI的渲染、事件的处理等。<h5 id="为什么微信小程序的DOM-API不完整？"><a href="#为什么微信小程序的DOM-API不完整？" class="headerlink" title="为什么微信小程序的DOM API不完整？"></a>为什么微信小程序的DOM API不完整？</h5>因为微信小程序的渲染线程和脚本线程是分开的，脚本线程独立在 <code>JSCore</code> 中，没有一个完整的浏览器对象。<h5 id="简单谈谈WXS"><a href="#简单谈谈WXS" class="headerlink" title="简单谈谈WXS?"></a>简单谈谈WXS?</h5>WXS(weixin script)，结合HTML，构建页面结构。<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">wxs</span> <span class="hljs-attr">module</span>=<span class="hljs-string">"m1"</span>&gt;</span>var msg = "hello world"; module.exports.message = msg;<span class="hljs-tag">&lt;/<span class="hljs-name">wxs</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;m1.message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></code></pre><h5 id="为什么setData操作会很昂贵？"><a href="#为什么setData操作会很昂贵？" class="headerlink" title="为什么setData操作会很昂贵？"></a>为什么setData操作会很昂贵？</h5></li></ol><p><strong>频繁用户交互的效果在小程序上表现是比较卡顿的，</strong> 例如页面有 2 个元素 A 和 B，用户在 A 上做 touchmove 手势，要求 B 也跟随移动。一次 <code>touchmove</code> 事件的响应过程为：</p><p>a、touchmove 事件从视图层（Webview）抛到逻辑层（App Service）<br>b、逻辑层（App Service）处理 touchmove 事件，再通过 setData 来改变 B 的位置</p><p>一次 touchmove 的响应需要经过 2 次的逻辑层和渲染层的通信以及一次渲染，通信(JSBridge)的耗时比较大。此外 setData 渲染也会阻塞其它脚本执行，导致了整个用户交互的动画过程会有延迟。</p><h5 id="谈谈小程序的生命周期函数"><a href="#谈谈小程序的生命周期函数" class="headerlink" title="谈谈小程序的生命周期函数"></a>谈谈小程序的生命周期函数</h5><p><strong>onLoad()</strong> 页面加载时触发，只会调用一次，可获取当前页面路径中的参数;<br><strong>onShow()</strong>  页面显示/切入前台时触发，一般用来发送数据请求(或者 set to foreground);<br><strong>onReady()</strong> 页面初次渲染完成时触发   只会调用一次，代表页面已可和视图层进行交互（当逻辑层通知渲染层 Send Initial Data，且渲染层 First Render 之后调用）；<br><strong>onHide()</strong> 页面隐藏/切入后台时触发(set to background)， 如底部tab切换到其他页面或小程序切入后台等；<br><strong>onUnload()</strong> 页面卸载时触发(destroy)，如redirectTo或navigateBack到其他页面时。</p><h5 id="小程序页面有哪些传递数据的方法"><a href="#小程序页面有哪些传递数据的方法" class="headerlink" title="小程序页面有哪些传递数据的方法"></a>小程序页面有哪些传递数据的方法</h5><ol><li>使用全局变量实现数据传递</li><li>页面跳转或重定向时，使用url带参数传递数据</li><li>使用组件模板 template传递参数</li><li>使用缓存传递参数</li><li>使用数据库传递数据</li></ol><h5 id="请谈谈微信小程序主要目录和文件的作用？"><a href="#请谈谈微信小程序主要目录和文件的作用？" class="headerlink" title="请谈谈微信小程序主要目录和文件的作用？"></a>请谈谈微信小程序主要目录和文件的作用？</h5><ul><li>project.config.json 项目配置文件，用得最多的就是配置是否开启https校验；</li><li>App.js   设置一些全局的基础数据等；</li><li>App.json 底部tab, 标题栏, 小程序的window背景色和路由等设置；</li><li>App.wxss 公共样式，引入iconfont等；</li><li>pages 里面包含一个个具体的页面；<ul><li>index.json (配置当前页面标题和引入组件等)；</li><li>index.wxml (页面结构)；</li><li>index.wxss (页面样式表)；</li><li>index.js (页面的逻辑，请求和数据处理等)；</li></ul></li></ul><h5 id="谈谈微信小程序-wxss样式"><a href="#谈谈微信小程序-wxss样式" class="headerlink" title="谈谈微信小程序.wxss样式"></a>谈谈微信小程序.wxss样式</h5><ol><li>新增加了尺寸单位rpx(tip: rpx换算px规则是屏幕宽度/750, iphone6下，1rpx = 0.5px)</li><li>提供了全局样式(app.wxss)和局部样式(page.wxss)</li><li>WXSS 仅支持部分 CSS 选择器( &gt;  :first-of-type :nth-child 均不支持)</li></ol><h4 id="七、HTTP协议"><a href="#七、HTTP协议" class="headerlink" title="七、HTTP协议"></a>七、HTTP协议</h4><h5 id="HTTP请求中的内容"><a href="#HTTP请求中的内容" class="headerlink" title="HTTP请求中的内容"></a>HTTP请求中的内容</h5><ul><li>请求行 <code>GET /images/logo.gif HTTP/1.1</code></li><li>首部<ul><li>通用首部</li><li>请求首部</li><li>响应首部</li><li>实体首部</li></ul></li><li>实体<h5 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h5></li><li>1**: 信息，服务器收到请求，需要请求者继续执行操作</li><li>2**: 成功，操作被成功接收并处理</li><li>3**: 重定向，需要进一步的操作以完成请求<ul><li>304 Not Modified 所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。</li></ul></li><li>4**: 客户端错误，请求包含语法错误或无法完成请求<ul><li>400 客户端请求的语法错误，服务端无法理解</li><li>403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404 Not Found 服务器无法根据客户端的请求找到资源（网页）</li></ul></li><li>5**: 服务器错误，服务器在处理请求的过程中发生了错误<ul><li>500 服务器内部错误</li><li>502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应<h5 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h5>往返时延，在计算机网络中它也是一个重要的性能指标，它表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延;<h5 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h5>只是数据报文的搬运工，不会对报文进行拆分和拼接操作，不保证有序且不丢失的传递到对端</li></ul></li><li>面向无连接</li><li>不可靠 -&gt; 高效</li></ul><p>在直播行业和即时对战游戏等实时性要求高的行业，UDP协议使用广泛</p><h5 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h5><p>TCP 基本是和 UDP 反着来，建立连接断开连接都需要先需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比 UDP 来说不那么的高效。是全双工协议。</p><h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><ul><li>URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。</li><li>ACK=1：代表确认接受,确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。</li><li>PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。</li><li>RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li><li>SYN=1：代表请求创立连接，当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。</li><li>FIN=1：代表请求释放连接。</li><li>seq：序列号，什么意思呢？当发送一个数据时，数据是被拆成多个数据包来发送，序列号就是对每个数据包进行编号，这样接受方才能对数据包进行再次拼接。</li><li>ack：这个代表下一个数据包的编号，这也就是为什么第二请求时，ack是seq + 1（tip: ack和ACK代表的意思不同）<h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5>客户端 —— SYN = 1, ACK = 0, seq = x ——- &gt; 服务端</li></ul><p>客户端 &lt; —– SYN = 1, ACK = 1, seq = y, ack = x + 1 ——– 服务端</p><p>客户端 —— ACK = 1, seq = x + 1, ack = y + 1——- &gt; 服务端</p><h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p>客户端 —— FIN ——- &gt; 服务端</p><p>客户端 &lt; —– ACK ——– 服务端</p><p>客户端 &lt; —– FIN ——– 服务端</p><p>客户端 —— ACK ——- &gt; 服务端</p><h5 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h5><p>ARQ协议其实就是超时重传机制。通过确认和超时重传机制保证数据的正确送达。</p><ul><li>停止等待ARQ协议</li><li>连续ARQ协议<h5 id="连续ARQ协议-gt-滑动窗口"><a href="#连续ARQ协议-gt-滑动窗口" class="headerlink" title="连续ARQ协议 - &gt; 滑动窗口"></a>连续ARQ协议 - &gt; 滑动窗口</h5>发送端窗口包含<code>已发送但未收到应答的数据</code>和<code>待发送的数据</code></li></ul><p>发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。</p><p>滑动窗口解决了数据的丢包、顺序不对和流量控制问题</p><h5 id="拥塞处理"><a href="#拥塞处理" class="headerlink" title="拥塞处理"></a>拥塞处理</h5><ul><li>慢开始算法</li><li>拥塞避免算法</li><li>快速重传</li><li>快速恢复<h4 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h4><h5 id="面向对象的基本要素"><a href="#面向对象的基本要素" class="headerlink" title="面向对象的基本要素"></a>面向对象的基本要素</h5><code>继承</code> <code>封装</code>和<code>多态</code><h5 id="JS适合用来面向对象吗？"><a href="#JS适合用来面向对象吗？" class="headerlink" title="JS适合用来面向对象吗？"></a>JS适合用来面向对象吗？</h5><h5 id="你在工作中是如何使用面向对象思想的？"><a href="#你在工作中是如何使用面向对象思想的？" class="headerlink" title="你在工作中是如何使用面向对象思想的？"></a>你在工作中是如何使用面向对象思想的？</h5></li></ul><p>明天需要上班，后续跟进补充！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一道JavaScript面向对象的面试题</title>
    <link href="/blog/2018/08/26/20180826/"/>
    <url>/blog/2018/08/26/20180826/</url>
    
    <content type="html"><![CDATA[<p>今日主要写一道面试题目来练练手。</p><h4 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h4><ul><li>某停车场，分3层，每层100个车位</li><li>每个车位都能监控到车辆的驶入和离开</li><li>车辆进入前，显示每层的空余车位数量</li><li>车辆进入时，摄像头可识别车牌号和时间</li><li>车辆出来时，出口显示器显示车牌号和停车时长</li></ul><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><pre><code class="hljs javascript"><span class="hljs-comment">// 停车场</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Park</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;        <span class="hljs-keyword">this</span>.parkNumList = [];    <span class="hljs-comment">// 每层空余车位</span>    &#125;    getPrakNumList() &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.parkNumList) &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`第<span class="hljs-subst">$&#123;i.floor&#125;</span>层停车场，剩余停车位<span class="hljs-subst">$&#123;i.parkNum&#125;</span>`</span>);        &#125;    &#125;    registerFloor(floor) &#123;        <span class="hljs-keyword">this</span>.parkNumList.push(floor);    &#125;&#125;<span class="hljs-comment">// 层数</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Floor</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(floor, num) &#123;        <span class="hljs-keyword">this</span>.floor = floor;       <span class="hljs-comment">// 层数</span>        <span class="hljs-keyword">this</span>.parkNum = num;       <span class="hljs-comment">// 该层剩余车空位</span>    &#125;    carEnter() &#123;        <span class="hljs-keyword">this</span>.parkNum = <span class="hljs-keyword">this</span>.parkNum - <span class="hljs-number">1</span>;    &#125;    carLeave() &#123;        <span class="hljs-keyword">this</span>.parkNum = <span class="hljs-keyword">this</span>.parkNum + <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-comment">// 停车位</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkSpace</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(num, belongFloor) &#123;        <span class="hljs-keyword">this</span>.parkSpaceNum = num;           <span class="hljs-comment">//停车位编号</span>        <span class="hljs-keyword">this</span>.belongFloor = belongFloor;    <span class="hljs-comment">//停车位属于哪一层  </span>        <span class="hljs-keyword">this</span>.isAir = <span class="hljs-literal">false</span>;                <span class="hljs-comment">//停车位是否空闲</span>    &#125;    monitorCarEnter() &#123;        <span class="hljs-keyword">this</span>.isAir = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">this</span>.belongFloor.carEnter();        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'-------停车位已监控到车辆进入------'</span>);    &#125;    monitorCarLeave() &#123;        <span class="hljs-keyword">this</span>.isAir = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">this</span>.belongFloor.carLeave();        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'-----停车位已监控到车辆离开-----'</span>);    &#125;&#125;<span class="hljs-comment">// 车</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(carNum) &#123;        <span class="hljs-keyword">this</span>.carNum = carNum;        <span class="hljs-comment">// 车牌号</span>        <span class="hljs-keyword">this</span>.carEnterTime = <span class="hljs-string">''</span>;      <span class="hljs-comment">// 车进入停车位的时间</span>        <span class="hljs-keyword">this</span>.carLeaveTime = <span class="hljs-string">''</span>;      <span class="hljs-comment">// 车离开停车位的时间</span>    &#125;    beforeEnter(park) &#123;        park.getPrakNumList();    &#125;    enter(parkSpace, camera, enterTime) &#123;        <span class="hljs-keyword">this</span>.carEnterTime = enterTime;        parkSpace.monitorCarEnter();        camera.shot(<span class="hljs-keyword">this</span>);    &#125;    leave(parkSpace, monitor, leaveTime) &#123;        <span class="hljs-keyword">this</span>.carLeaveTime = leaveTime;        parkSpace.monitorCarLeave();        monitor.show(<span class="hljs-keyword">this</span>);    &#125;&#125;<span class="hljs-comment">// 摄像头</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Camera</span> </span>&#123;    shot(car) &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`摄像头已识别车牌号：<span class="hljs-subst">$&#123;car.carNum&#125;</span>`</span>);        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`摄像头已识别车辆进入时间：<span class="hljs-subst">$&#123;car.carEnterTime&#125;</span>`</span>);    &#125;&#125;<span class="hljs-comment">// 出口显示器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;    show(car) &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`出口显示器显示车牌号：<span class="hljs-subst">$&#123;car.carNum&#125;</span>`</span>);        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`出口显示器显示车辆停车时长：<span class="hljs-subst">$&#123;car.carEnterTime&#125;</span> - <span class="hljs-subst">$&#123;car.carLeaveTime&#125;</span>`</span>);    &#125;&#125;<span class="hljs-comment">// 舒店长要开停车场营业啦～</span><span class="hljs-keyword">let</span> park = <span class="hljs-keyword">new</span> Park();                     <span class="hljs-comment">//初始化停车场</span><span class="hljs-keyword">let</span> firstFloor = <span class="hljs-keyword">new</span> Floor(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);        <span class="hljs-comment">//初始化一楼停车场</span>park.registerFloor(firstFloor);<span class="hljs-keyword">let</span> secondFloor = <span class="hljs-keyword">new</span> Floor(<span class="hljs-number">2</span>, <span class="hljs-number">100</span>);       <span class="hljs-comment">//初始化二楼停车场</span>park.registerFloor(secondFloor);<span class="hljs-keyword">let</span> thirdFloor = <span class="hljs-keyword">new</span> Floor(<span class="hljs-number">3</span>, <span class="hljs-number">100</span>);        <span class="hljs-comment">//初始化三楼停车场</span>park.registerFloor(thirdFloor);<span class="hljs-keyword">let</span> camera = <span class="hljs-keyword">new</span> Camera();                 <span class="hljs-comment">//初始化摄像头</span><span class="hljs-keyword">let</span> monitor = <span class="hljs-keyword">new</span> Monitor();               <span class="hljs-comment">//初始化出口显示屏</span><span class="hljs-comment">// 欢迎第一辆车停车～</span><span class="hljs-keyword">let</span> car1 = <span class="hljs-keyword">new</span> Car(<span class="hljs-string">'桂G8888'</span>);car1.beforeEnter(park);<span class="hljs-keyword">let</span> parkSpace1 = <span class="hljs-keyword">new</span> ParkSpace(<span class="hljs-number">88</span>, secondFloor);     <span class="hljs-comment">//这个车想停在二楼停车场的88号位置</span>car1.enter(parkSpace1, camera, <span class="hljs-string">'12:45:30'</span>);<span class="hljs-comment">// 然后又来了第二辆车~</span><span class="hljs-keyword">let</span> car2 = <span class="hljs-keyword">new</span> Car(<span class="hljs-string">'赣B8888'</span>);car2.beforeEnter(park);<span class="hljs-keyword">let</span> parkSpace2 = <span class="hljs-keyword">new</span> ParkSpace(<span class="hljs-number">88</span>, thirdFloor);     <span class="hljs-comment">//这个车想停在三楼停车场的88号位置</span>car2.enter(parkSpace2, camera, <span class="hljs-string">'23:01:30'</span>);<span class="hljs-comment">// 然后又来了第三辆车～</span><span class="hljs-keyword">let</span> car3 = <span class="hljs-keyword">new</span> Car(<span class="hljs-string">'粤A6666'</span>);car3.beforeEnter(park);<span class="hljs-keyword">let</span> parkSpace3 = <span class="hljs-keyword">new</span> ParkSpace(<span class="hljs-number">88</span>, thirdFloor);     <span class="hljs-comment">//这个车想停在一楼停车场的88号位置</span>car3.enter(parkSpace3, camera, <span class="hljs-string">'19:01:30'</span>);<span class="hljs-comment">// 然后又来了第四辆车～但是没有停车～唉</span><span class="hljs-keyword">let</span> car4 = <span class="hljs-keyword">new</span> Car(<span class="hljs-string">'粤A6666'</span>);car4.beforeEnter(park);</code></pre><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="/blog/img/20180826/1.png" srcset="/blog/img/loading.gif" alt="result.png"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>尽管完成了题目的要求，但是后续仍然需要优化一下。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git SSH配置</title>
    <link href="/blog/2018/08/23/20180823/"/>
    <url>/blog/2018/08/23/20180823/</url>
    
    <content type="html"><![CDATA[<p>在使用 GitHub、Coding 等 Git 服务的时候，经常需要配置 SSH key，以便于进行 Git 操作时候的身份认证，在这里记录和总结下配置的过程。<br><img src="/blog/img/20180823/1.png" srcset="/blog/img/loading.gif" alt="ssh.jpg"></p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p><strong>Secure Shell（缩写为 SSH）</strong>即“安全外壳协议”，是一项创建在应用层和传输层基础上的安全协议，为计算机上的 Shell（壳层）提供安全的传输和使用环境。</p><p>传统的网络服务程序，如 FTP、POP 和 Telnet 其本质都是不安全的，因为它们在网络上使用明文传送数据、用户账号和用户口令，很容易受到中间人攻击方式的攻击。而 SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。其优点如下：</p><ul><li>通过 SSH 可以对所有的传输的数据进行加密。</li><li>SSH 为其传输的数据可以是经过压缩的，可以加快传输的速度。</li></ul><p>SSH 提供两种级别的安全验证：</p><ul><li>基于密码。通过账号和密码登陆远程主机后，所有的传输数据都会被加密。由于别的服务器可能在冒充真正的服务器，所以无法避免中间人攻击。</li><li>基于密钥。需要创建一对密钥，把公共密钥放在需要访问的服务器上，客户端软件会向服务器发出请求用公共的密钥进行安全验证，服务器收到请求后先在该服务器的用户根目录下寻找用户的公有密钥，然后把它和用户发送的过来的公有密钥进行比较，如果两个密钥一致，服务器就用公有密钥加密“质询”（challenge）并把它发送给客户端软件。该方式可以避免中间人攻击。</li></ul><h2 id="Git-SSH"><a href="#Git-SSH" class="headerlink" title="Git SSH"></a>Git SSH</h2><p>通过上面的介绍，知道了首先要在本地和 GitHub 之间建立连接，这种连接可以通过 SSH 进行。</p><h3 id="配置-Git-的用户名和邮箱"><a href="#配置-Git-的用户名和邮箱" class="headerlink" title="配置 Git 的用户名和邮箱"></a>配置 Git 的用户名和邮箱</h3><p>如果是首次使用 Git，需要先设置<code>username</code>和<code>email</code>。</p><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.name <span class="hljs-string">"shudz"</span>git<span class="hljs-built_in"> config </span>--global user.email <span class="hljs-string">"shudz@qq.com"</span></code></pre><h3 id="生成-SSH-key"><a href="#生成-SSH-key" class="headerlink" title="生成 SSH key"></a>生成 SSH key</h3><p>许多 Git 服务器都使用了 SSH 公钥进行认证。为了向 Git 服务器提供 SSH 公钥。如果某系统用户尚未拥有密钥，必须事先为其生成一份。这个过程在所有操作系统上是相似的。</p><p>首先，需要确定自己是否已经拥有密钥。默认情况下，用户的 SSH 密钥存储在<code>~/.ssh</code>目录下。进入该目录列出其中内容，便可以快速确定自己是否已经拥有密钥：</p><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.ssh</span><span class="hljs-keyword">ls</span></code></pre><p>在目录下寻找一对以id_rsa命名的文件，其中一个带有<code>.pub</code>扩展名。<code>.pub</code>文件是公钥，另一个则是密钥。如果找不到这样的文件（或者根本没有<code>.ssh</code>目录），可以通过运行<code>ssh-keygen</code>来创建它们。</p><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">"shudz@qq.com"</span></code></pre><p>首先ssh-keygen会确定密钥的存储位置（默认是<code>.ssh/id_rsa</code>），然后它会要求你输入两次密钥口令。如果不想在使用密钥时输入口令，将其留空直接回车即可。<br><img src="/blog/img/20180823/2.png" srcset="/blog/img/loading.gif" alt="rsa.png"></p><p>此时，可以在用户目录找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是 SSH Key 的密钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><h3 id="添加-SSH-key-到-GitHub-账户"><a href="#添加-SSH-key-到-GitHub-账户" class="headerlink" title="添加 SSH key 到 GitHub 账户"></a>添加 SSH key 到 GitHub 账户</h3><p>登陆 GitHub，打开 “Account Setting” ，在设置边栏选择 “SSH and GPG keys” 选项，点击 “New SSH key” 按钮，填写任意 Title，在 Key 文本框粘贴<code>id_rsa.pub</code>文件的内容：</p><p>点击 “Add Key” ，然后输入确认密码添加完成，就可以看到已经添加的 Key。<br><img src="/blog/img/20180823/3.png" srcset="/blog/img/loading.gif" alt="github.png"></p><h3 id="测试-SSH-连接"><a href="#测试-SSH-连接" class="headerlink" title="测试 SSH 连接"></a>测试 SSH 连接</h3><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com</code></pre><p>看到提示是否连接的信息，键入yes回车，如果看到包含用户名的信息，就说明成功了。</p><p>到这里，SSH就配置完成了，赶快去github尝试提交代码吧～</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript作用域和作用域链</title>
    <link href="/blog/2018/06/10/20180610/"/>
    <url>/blog/2018/06/10/20180610/</url>
    
    <content type="html"><![CDATA[<p><img src="/blog/img/20180610/1.jpg" srcset="/blog/img/loading.gif" alt="javascript.jpg"><br>工作处于实习阶段，趁着现在还有点空闲时间，又忍不住掏出床头的《JavaScript高级程序设计》，重新温习了一遍。<br>在串讲作用域和作用域链之前，先梳理清楚几个重要概念。</p><h2 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h2><p>执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有与其相关的<strong>变量对象</strong>。在web浏览器中，全局的执行环境是window，因此全局变量和函数都是作为window对象的属性和方法创建的。</p><h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>环境中定义的变量和函数都保存在变量对象中，解析器在处理数据的时候会在后台使用它。（注：在函数的执行环境中，变量对象称为<strong>活动对象</strong>）<br>####环境栈<br>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的执行环境被压入环境栈中，当函数执行完毕，函数从执行栈中弹出，将控制权返回给之前的执行环境。</p><p>弄清楚了以上概念，看代码示例。</p><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> leader = <span class="hljs-string">"shuDianZhang"</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">employeeHouse</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">var</span> hostName = <span class="hljs-string">"liHua"</span>;        <span class="hljs-comment">// 主人名</span>    <span class="hljs-keyword">var</span> furniture = <span class="hljs-string">"sofa"</span>;        <span class="hljs-comment">// 家具</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFurniture</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> furniture;    &#125;    getFurniture();&#125;employeeHouse();</code></pre><p>执行该代码，首先压入栈底的是全局执行环境window，全局执行环境中的变量对象上有变量leader和函数employeeHouse()。当执行employeeHouse()，执行流进入函数内部的时候，employeeHouse()的执行环境压入环境栈。代码继续执行，当执行getFurniture()函数的时候，其执行环境继续压入环境栈。整个流程大致如下图所示。<br><img src="/blog/img/20180610/2.png" srcset="/blog/img/loading.gif" alt="环境栈变化图.png"><br>当getFurniture()函数执行结束之后，getFurniture()函数的执行环境从环境栈中弹出，紧接着，employeeHouse()函数的执行环境从环境栈中弹出，当我们关闭网页或者浏览器时，全局执行环境自动销毁。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在JavaScript中是没有块级作用域的。作用域只有全局作用域和局部作用域（函数的执行环境）之分。也许是为了弥补JavaScript这一设计缺陷，在ES6中引入了<strong>let</strong>。<br>####作用域链<br>在了解作用域链之前，我们不妨设想作用域链的用途是什么？如果没有作用域链，结果会是怎样？如果没有作用链，就相当于缺少了一套访问变量和函数的规则，没有了这套规则的约束，就不能明确变量和函数的作用范围，说白了就会乱套。因此，作用域链的用途，<strong>是保证对执行环境有权访问的所有变量和函数的有序访问。</strong>作用域链的制定的规则就是<strong>内部环境可以通过作用域链访问所有外部环境，但是外部环境不能访问内部环境中的任何变量和函数。</strong>作用域链的搜所过程是：<strong>从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果找到了，搜索过程停止，否则继续沿着作用域链向上搜索，一直追溯到全局执行环境中的变量对象为止。</strong><br>当代码在一个环境中执行时，会创建变量对象的一个作用域链。<strong>作用域链的前端</strong>始终是当前执行的代码所在环境的变量对象。<strong>作用域链的末端</strong>始终是全局执行环境的变量对象。</p><p>好了好了，重点来了。为了方便记忆，我们把作用域链看作是一串烧烤。（夜晚写这个，肚子有点饿了）假定这串烧烤是羊肉串，那么穿在这竹签上的羊肉便是<strong>变量对象</strong>。<br><img src="/blog/img/20180610/3.png" srcset="/blog/img/loading.gif" alt="烤肉串类比图.png"></p><p>以最开始的代码段为例，当代码执行getFurniture()函数，执行流进入getFurniture()函数内部的时候，可以知道，当前执行的代码所在环境是getFurniture()的执行环境。这时候，可以想象服务员递给你一串“羊肉串”，羊肉串的最顶端就是getFurniture()执行环境的变量对象。</p><p>好了，作用域和作用域链的介绍先告一段落，后续会有补充，喜欢的朋友点个赞吧~一起学习，一起进步！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【翼签到】微信小程序实战</title>
    <link href="/blog/2018/06/05/20180605/"/>
    <url>/blog/2018/06/05/20180605/</url>
    
    <content type="html"><![CDATA[<p>上班实习的第一天，接到任务，要求开发一个微信小程序。小程序名为【翼签到】，用作公司内部发布大会消息和报名签到。<br>接到设计稿，估摸了一下，发现页面比较多，还好导师给我安排一个小伙伴进行协作开发。他主要负责发布流程而我主要负责<strong>着陆流程</strong>、<strong>审批流程</strong>和<strong>后台接口</strong>的开发。<br><img src="/blog/img/20180605/1.jpeg" srcset="/blog/img/loading.gif" alt="timg.jpeg"></p><h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><p>开发微信小程序是一件很有意思的事情。原因有二：</p><ul><li>简洁易懂的中文文档</li><li>所见即所得的开发快感<br>入门开发小程序的成本是相当低的，但是想要写好来，也是一件不简单的事情，也踩过了一些坑，在这里和大家分享一下。<h3 id="1-setData"><a href="#1-setData" class="headerlink" title="1.setData()"></a>1.setData()</h3>调用setData()改变data中的数据，并不是实时的。频繁的（毫秒级）调用setData()会严重影响页面性能。至于原理，微信小程序的文档说得很清楚了。<br> <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips.html?search-key=%E6%80%A7%E8%83%BD" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips.html?search-key=%E6%80%A7%E8%83%BD</a><h3 id="2-生命周期函数onShow"><a href="#2-生命周期函数onShow" class="headerlink" title="2.生命周期函数onShow"></a>2.生命周期函数onShow</h3>官方文档给这个声明周期函数给出的介绍是：<strong>onShow: 页面显示，每次打开页面都会调用一次。</strong>当我们调用微信小程序API路由跳转至一个页面的时候，该页面挂载的onShow函数，往往都会执行一次。<h3 id="3-在视图容器swiper中使用map组件"><a href="#3-在视图容器swiper中使用map组件" class="headerlink" title="3.在视图容器swiper中使用map组件"></a>3.在视图容器swiper中使用map组件</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">swiper</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span>大会介绍<span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span>大会议程<span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span>出席嘉宾<span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span>地图定位    <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">swiper</span>&gt;</span></code></pre>官方文档明确指出<strong><map>组件不能嵌套在<swiper>组件当中使用。</strong>上面的代码违反了这条规定。出现的结果就是：在微信开发者工具中的模拟器测试，四个<swiper-item>能够流畅切换，表现正常。但是，当在手机上进行测试的时候，便出现了<map>组件停留在原地，不会随着父元素的<swiper-item>滑动的问题。<br>对于这样的问题，目前的解决方案是：使用<image>组件替换<map>组件，也就是展示一张静态的假地图。当用户需要操作地图的时候，<image>组件隐藏，将真正需要展示<map>组件显示出来即可。<h3 id="4-微信小程序启动机制"><a href="#4-微信小程序启动机制" class="headerlink" title="4.微信小程序启动机制"></a>4.微信小程序启动机制</h3>微信小程序只有<strong>冷启动</strong>和<strong>热启动</strong>之分。当用户打开过某个小程序，然后在一定时间内（目前为5分钟）再次打开，只需将后台态的小程序切换到前台，这是热启动。冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。<br>微信小程序被销毁的情况有两种：</li></ul><p>1.当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁<br>2.当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁</p><h3 id="5-密切关注微信小程序API的变动"><a href="#5-密切关注微信小程序API的变动" class="headerlink" title="5.密切关注微信小程序API的变动"></a>5.密切关注微信小程序API的变动</h3><p>作为一个系统的开发者和维护者，要关注官方文档中API的变动，因为某些API的变动可能会影响到使用该API的模块功能，因此需要做出及时的调整。例如，在今年4月份的时候，微信小程序变动了获取用户信息的接口(wx.getUserInfo)，具体见下图：<br><img src="/blog/img/20180605/2.png" srcset="/blog/img/loading.gif" alt="获取用户信息接口调整.png"><br>简单来说，此次更新，是微信小程序获取用户信息这一操作更加倾向于用户主动提交个人信息。如果程序开发者不及时更新维护的话，那么原先调用wx.getUserInfo这一接口，将会报错。<br>在这种情况下，拿【有赞服务指南小程序】举例，该小程序在获取用户头像的时候（用户信息的一部分），明显的修改为“点击获取头像”，指引用户主动点击提交个人信息以获取个人头像信息。就算用户出于安全考虑不点击，那么小程序也不会调用wx.getUserInfo接口，因此，也不会产生错误。<br><img src="/blog/img/20180605/3.jpg" srcset="/blog/img/loading.gif" alt="有赞服务指南小程序.jpg"></p><h2 id="后台技术栈"><a href="#后台技术栈" class="headerlink" title="后台技术栈"></a>后台技术栈</h2><p>依照公司内部的技术栈体系，后台技术栈选用了Node+Express4.0+MySQL。作为一个已经有Koa框架开发经验的我来说，使用Express开发后台接口的难度并不高。整个开发周期，花费在前端开发的时间远比开发后台接口所花的时间多得多。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>和我搭档的小伙伴，在发布流程开发至一半的时候，离职返校答辩去了，留下我孤零零的揽下整个小程序的开发。于是，在他编写的代码基础上，我继续对发布流程进行开发，让我有了不小的收获。</p><p><strong>1.一个函数只做一件事情</strong><br>下面代码的封装了一个getConferenceList()方法，由其函数名可以知道这个函数的大概作用——获取大会列表。但是实际上，这个函数中做了太多的事情，除了获取大会列表之外，调用了showLoading()展示loading动画，调用了stopPullDownRefresh()取消下载刷新，调用了showModal()弹出模态框，最后还调用了setData()修改了数据层…<br>如此杂乱的函数，<strong>复用率</strong>和<strong>自由度</strong>都大打折扣！</p><pre><code class="hljs reasonml">getConferenceList: <span class="hljs-keyword">function</span> (data, sessionId, that) &#123;  wx.show<span class="hljs-constructor">Loading(&#123; <span class="hljs-params">title</span>: '加载中', <span class="hljs-params">mask</span>: <span class="hljs-params">true</span> &#125;)</span>;  api.conference<span class="hljs-constructor">List(<span class="hljs-params">data</span>, <span class="hljs-params">sessionId</span>)</span>.<span class="hljs-keyword">then</span>((res) =&gt; &#123;    <span class="hljs-keyword">if</span> (res.data<span class="hljs-operator"> &amp;&amp; </span>res.data.code<span class="hljs-operator"> === </span><span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">let</span> conferenceList = res.data.conferenceList;      that.set<span class="hljs-constructor">Data(&#123; <span class="hljs-params">conferenceList</span> &#125;, <span class="hljs-params">function</span> ()</span> &#123;        wx.stop<span class="hljs-constructor">PullDownRefresh()</span>;        wx.hide<span class="hljs-constructor">Loading()</span>;      &#125;);    &#125; <span class="hljs-keyword">else</span> &#123;      wx.hide<span class="hljs-constructor">Loading()</span>;      wx.show<span class="hljs-constructor">Modal(&#123; <span class="hljs-params">title</span>: '服务器开小差啦', <span class="hljs-params">content</span>: '请联系管理员或稍后重试' &#125;)</span>    &#125;  &#125;,<span class="hljs-function"> <span class="hljs-params">err</span> =&gt;</span> &#123;    wx.hide<span class="hljs-constructor">Loading()</span>;    wx.show<span class="hljs-constructor">Modal(&#123; <span class="hljs-params">title</span>: '与服务器通讯错误', <span class="hljs-params">content</span>: '请联系管理员或稍后重试' &#125;)</span>  &#125;);&#125;</code></pre><p>下拉刷新，调用getConferenceList()方法的时候，弊病就暴露出来了：<br>1.不能够的控制调用setData()和stopPullDownRefresh()的时机，因为getConferenceList()内部已经调用了。<br>2.下拉刷新自带loading动画，不需要调用showLoading()方法，getConferenceList()内部调用showLoading()方法很多余。</p><pre><code class="hljs reasonml">onPullDownRefresh: <span class="hljs-keyword">function</span> <span class="hljs-literal">()</span> &#123;  <span class="hljs-keyword">let</span> that = this;  that.set<span class="hljs-constructor">Data(&#123; <span class="hljs-params">page</span>: 1, <span class="hljs-params">conferenceList</span>: [], <span class="hljs-params">finish</span>: <span class="hljs-params">false</span> &#125;, <span class="hljs-params">function</span> ()</span> &#123;    that.get<span class="hljs-constructor">ConferenceList(&#123; <span class="hljs-params">page</span>: <span class="hljs-params">that</span>.<span class="hljs-params">data</span>.<span class="hljs-params">page</span>, <span class="hljs-params">size</span>: <span class="hljs-params">that</span>.<span class="hljs-params">data</span>.<span class="hljs-params">size</span> &#125;, <span class="hljs-params">that</span>.<span class="hljs-params">data</span>.<span class="hljs-params">sessionId</span>, <span class="hljs-params">that</span>)</span>;  &#125;);&#125;</code></pre><p>正因为如此，所以才明白了<strong>“一个函数只做一件事情”</strong>的重要性了。<br>尝试对getConferenceList()方法进行改造，去掉多余的操作，让其只作为获取大会列表信息的一个封装 。改造后的代码如下。</p><pre><code class="hljs groovy"><span class="hljs-string">getConferenceList:</span> function (data, sessionId) &#123;  <span class="hljs-keyword">return</span> api.conferenceList(data, sessionId).then((res) =&gt; &#123;    <span class="hljs-keyword">if</span> (res.data &amp;&amp; res.data.code === <span class="hljs-number">1</span>) &#123;      let conferenceList = res.data.conferenceList;      <span class="hljs-keyword">return</span> conferenceList;    &#125; <span class="hljs-keyword">else</span> &#123;      wx.showToast(&#123; <span class="hljs-string">title:</span> <span class="hljs-string">'服务端异常'</span>, <span class="hljs-string">mask:</span> <span class="hljs-literal">true</span>, <span class="hljs-string">icon:</span> <span class="hljs-string">'none'</span>, <span class="hljs-string">duration:</span> <span class="hljs-number">500</span> &#125;);    &#125;  &#125;, err =&gt; &#123;    wx.showToast(&#123; <span class="hljs-string">title:</span> <span class="hljs-string">'服务器连接失败'</span>, <span class="hljs-string">mask:</span> <span class="hljs-literal">true</span>, <span class="hljs-string">icon:</span> <span class="hljs-string">'none'</span>, <span class="hljs-string">duration:</span> <span class="hljs-number">500</span> &#125;);  &#125;);&#125;</code></pre><p>改造后的getConferenceList()方法内部返回一个promise对象，将获取大会信息列表之后的控制权交至消费者的手中，而本身只做一件事，<strong>获取大会消息列表</strong>。<br>这样一来，便可以控制调用setData()和stopPullDownRefresh()的时机，灵活度更高。</p><pre><code class="hljs reasonml">onPullDownRefresh: <span class="hljs-keyword">function</span> <span class="hljs-literal">()</span> &#123;  <span class="hljs-keyword">let</span> that = this;  that.get<span class="hljs-constructor">ConferenceList(&#123; <span class="hljs-params">page</span>: 1, <span class="hljs-params">size</span>: <span class="hljs-params">that</span>.<span class="hljs-params">data</span>.<span class="hljs-params">size</span> &#125;, <span class="hljs-params">that</span>.<span class="hljs-params">data</span>.<span class="hljs-params">sessionId</span>)</span>.<span class="hljs-keyword">then</span>((value) =&gt; &#123;    that.set<span class="hljs-constructor">Data(&#123; <span class="hljs-params">page</span>: 1, <span class="hljs-params">conferenceList</span>: <span class="hljs-params">value</span> &#125;, <span class="hljs-params">function</span> ()</span> &#123;      wx.stop<span class="hljs-constructor">PullDownRefresh()</span>    &#125;);  &#125;);&#125;</code></pre><p><strong>2.合理控制数据流</strong><br>一个合格的前端开发工程师一定是善于控制数据流的，合理的控制数据流首先需要明确每个数据的生命周期，是伴随整个小程序的生命周期还是执行完某个函数就销毁了。确定了生命周期再选择存储数据的方式，是存储在localStorage、sessionStorage还是挂载到全局对象又或者仅仅需要路由传值，这些都需要根据数据的生命周期去考量。</p><p>喜欢这篇文章的朋友们，请点个赞再走哦～</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BFC原理及其应用</title>
    <link href="/blog/2018/06/03/20180603/"/>
    <url>/blog/2018/06/03/20180603/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是BFC？"><a href="#什么是BFC？" class="headerlink" title="什么是BFC？"></a>什么是BFC？</h2><p>BFC即Block Formatting Context的缩写，中文翻译过来就是块级格式化上下文。</p><h2 id="BFC的原理"><a href="#BFC的原理" class="headerlink" title="BFC的原理"></a>BFC的原理</h2><p>本质上就是BFC得渲染规则，总结起来有四点：</p><ul><li>属于同一个BFC的俩个相邻的元素的margin会发生重叠</li><li>BFC的元素不会与浮动元素产生重叠</li><li>BFC的元素是一个独立的容器，容器内的元素不会影响容器外部的元素，相反，容器外的元素也不会影响容器内的元素</li><li>计算BFC的元素的高度的时候，浮动元素也会参与计算</li></ul><h2 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC?"></a>如何创建BFC?</h2><ul><li>float值不为none </li><li>position为absolute或fixed </li><li>display为inline-block，table-cell，table-caption，flex； </li><li>overflow不为visible</li></ul><h2 id="BFC的使用场景"><a href="#BFC的使用场景" class="headerlink" title="BFC的使用场景"></a>BFC的使用场景</h2><p>BFC的使用场景，紧贴BFC的原理进行阐述。<br>（1） BFC的元素垂直方向的边距会发生重叠</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>        * &#123;            padding: 0;            margin: 0;        &#125;<span class="css">        <span class="hljs-selector-class">.container</span> &#123;</span><span class="css">            <span class="hljs-comment">/* 创建BFC */</span></span>            overflow: hidden;        &#125;<span class="css">        <span class="hljs-selector-class">.block</span> &#123;</span>            height: 100px;            margin: 10px 0 30px 0;            background: greenyellow;        &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block"</span>&gt;</span>我是第一个BFC<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block"</span>&gt;</span>我是第二个BFC<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block"</span>&gt;</span>我是第三个BFC<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>由于BFC内部元素的垂直方向的边距会发生重叠，因此第一个block和第二个block相距30px，并不是40px。因此，运行结果如下入所示。<br><img src="/blog/img/20180603/1.png" srcset="/blog/img/loading.gif" alt="BFC_demo1.png"></p><p>（2） BFC的元素不会与浮动元素产生重叠</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>       * &#123;           padding: 0;           margin: 0;       &#125;<span class="css">       <span class="hljs-selector-class">.left</span> &#123;</span>           float: left;           width: 200px;           height: 400px;           background: yellowgreen;       &#125;<span class="css">       <span class="hljs-selector-class">.right</span> &#123;</span>           height: 500px;           background: violet;       &#125;   <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>运行结果如下图所示：<br><img src="/blog/img/20180603/2.png" srcset="/blog/img/loading.gif" alt="BFC_demo2.png"><br>可以发现，right类和left类发生了重叠，若业务要求我们right类和left类不能重叠，相互独立，这时候我们可以使用BFC的渲染规则，只需添加一行代码便可达到这一目的，对代码进行改造。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>       * &#123;           padding: 0;           margin: 0;       &#125;<span class="css">       <span class="hljs-selector-class">.left</span> &#123;</span>           float: left;           width: 200px;           height: 400px;           background: yellowgreen;       &#125;<span class="css">       <span class="hljs-selector-class">.right</span> &#123;</span>           height: 500px;           background: violet;<span class="css">           <span class="hljs-comment">/* 创建BFC */</span></span>           overflow: hidden;       &#125;   <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>查看运行结果，果然达到了我们想要的效果。<br><img src="/blog/img/20180603/3.png" srcset="/blog/img/loading.gif" alt="BFC_demo3.png"></p><p>（3）计算BFC的元素的高度的时候，浮动元素也会参与计算<br>利用这条BFC的渲染规则，我们可以很好的利用其作清除浮动。老规矩，上代码。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>      * &#123;          padding: 0;          margin: 0;      &#125;<span class="css">      <span class="hljs-selector-class">.parent</span> &#123;</span>          background: red;      &#125;<span class="css">      <span class="hljs-selector-class">.children</span> &#123;</span>          float: left;          height: 300px;          width: 400px;          background: springgreen;      &#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"children"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><img src="/blog/img/20180603/4.png" srcset="/blog/img/loading.gif" alt="BFC_demo4.png"><br>从运行结果可以看出，由于children类浮动脱离了文档流，因此没有把parent类的高度撑开，parent类高度为0，没有显示出来。因此我们可以利用BFC元素计算高度的时候，浮动元素也会参与计算这一BFC渲染规则，对其进行改造，同样是增添一行代码，改造后的代码如下。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>       * &#123;           padding: 0;           margin: 0;       &#125;<span class="css">       <span class="hljs-selector-class">.parent</span> &#123;</span>           background: red;<span class="css">           <span class="hljs-comment">/* 创建BFC */</span></span>           overflow: hidden;       &#125;<span class="css">       <span class="hljs-selector-class">.children</span> &#123;</span>           float: left;           height: 300px;           width: 400px;           background: springgreen;       &#125;   <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"children"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><img src="/blog/img/20180603/5.png" srcset="/blog/img/loading.gif" alt="BFC_demo5.png"><br>给parent类创建了BFC之后，在计算parent类高度的时候，也会把浮动元素的高度计算在其中，这也算是清除浮动了吧。</p><p>如果觉得本文对你有收获的朋友，请点个赞，接下来的日子我会继续更新更好的技术博客！谢谢~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mongodb数据库设计</title>
    <link href="/blog/2018/03/10/20180310/"/>
    <url>/blog/2018/03/10/20180310/</url>
    
    <content type="html"><![CDATA[<h2 id="范示化"><a href="#范示化" class="headerlink" title="范示化"></a>范示化</h2><p>数据表示的方式有很多种，其中最重要的问题之一就是在多大程度上对数据进行范式化。<br><img src="/blog/img/20180310/1.jpg" srcset="/blog/img/loading.gif" alt="mongoDB.jpg"></p><p><strong>范式化（normalization）</strong>是将数据分散到多个不同的集合，不同集合之间可以相互引用数据。虽然很多文档可以引用某一块数据，但是这块数据只存储在一个集合中。所以，如果要修改这块数据，只需修改保存这块数据的那一个文档就行了。但是，MongoDB没有提供连接（join）工具，所以在不同集合之间执行连接查询需要进行多次查询。</p><p><strong>反范式化（denormalization）</strong>与范式化相反：将每个文档所需的数据都嵌入在文档内部。每个文档都拥有自己的数据副本，而不是所有文档共同引用同一个数据副本。这意味着，如果信息发生了变化，那么所有相关文档都需要进行更新，但是在执行查询时，只需要一次查询，就可以得到所有数据。</p><p><strong>决定何时采用范式化何时采用反范式化时比较困难的。范式化能够提高数据写入速度，反范式化能够提高数据读取速度。需要根据自己应用程序的使用场景进行权衡。</strong></p><p>教科书上介绍范式化的一个例子可能是将用户和用户地址保存在不同的集合中。但是，人们几乎不会改变住址，所以不应该为了这种概率极小的情况（某人改变了住址）而牺牲每一次查询的效率。在这种情况下，应该将地址内嵌在用户文档中。</p><h2 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h2><p>一个集合中包含的对其他集合的引用数量叫做基数（cardinality）。常见的关系有一对一、一对多、多对多。假如有一个博客应用程序。每篇博客文章（post）都有一个标题（title），这是一个对一个的关系。每个作者（author）可以有多篇文章，这是一个对多的关系。每篇文章可以有多个标签（tag），每个标签可以在多篇文章中使用，所以这是一个多对多的关系。</p><p>在MongoDB中，many（多）可以被分拆为两个子分类：many（多）和few（少）。假如，作者和文章之间可能是一对少的关系：每个作者只发表了为数不多的几篇文章。博客文章和标签可能是多对少的关系：文章数量实际上很可能比标签数量多。博客文章和评论之间是一对多的关系：每篇文章可以拥有很多条评论。</p><p>只要确定了少与多的关系，就可以比较容易地在内嵌数据和引用数据之间进行权衡。通常来说，“少”的关系使用内嵌的方式会比较好，“多”的关系使用引用的方式比较好。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>利用跨域资源共享CORS解决跨域问题</title>
    <link href="/blog/2018/03/09/20180309/"/>
    <url>/blog/2018/03/09/20180309/</url>
    
    <content type="html"><![CDATA[<p>最近在琢磨前后端分离，难免会碰到跨域问题。</p><p>首先弄清楚，跨域指的是浏览器不能执行其他网站的脚本。它是由<strong>浏览器</strong>的同源策略造成的，是浏览器施加的安全限制。</p><h2 id="何为同源？"><a href="#何为同源？" class="headerlink" title="何为同源？"></a>何为同源？</h2><p>URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。</p><h2 id="同源策略（是浏览器实施的）"><a href="#同源策略（是浏览器实施的）" class="headerlink" title="同源策略（是浏览器实施的）"></a>同源策略（是浏览器实施的）</h2><p>浏览器的同源策略，限制了来自不同源的”document”或脚本对当前”document”读取或设置某些属性 —— 从一个域上加载的脚本不允许访问另外一个域的文档属性。<br>在浏览器中，等标签都可以加载跨域资源，而不受同源限制，但浏览器限制了JavaScript的权限使其不能读、写加载的内容。<br>另外同源策略只对网页的HTML文档做了限制，对加载的其他静态资源如javascript、css、图片等仍然认为属于同源。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>对于跨域常见的解决方案一般会想到以下几种方案</p><ul><li>使用jsonp。</li><li>修改document.domain跨子域</li><li>iframe</li><li>反向代理</li></ul><p>若想要详细了解以上解决方案，自行百度，本文主要介绍使用<strong>跨域资源共享CORS</strong>来解决跨域问题</p><p>首先CORS需要浏览器和服务器同时支持。<br><strong>浏览器</strong>直接发出CORS请求。在头信息之中，增加一个Origin字段。Origin字段用来说明，本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。<br><strong>服务器</strong>返回一个正常的http回应。浏览器查看回应的头信息没有包含Access-Control-Allow-Origin字段，检查自己是否所处其中。若不在其中，抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。若在其中，则CORS请求成功。</p><blockquote><p>注意：Access-Control-Allow-Origin字段是html5新增的一项标准功能，因此 IE10以下版本的浏览器是不支持的，因此，如果要求兼容IE9或更低版本的ie浏览器，会导致使用此种方式的跨域请求以及传递Cookie的计划夭折</p></blockquote><p><img src="/blog/img/20180309/1.png" srcset="/blog/img/loading.gif" alt="origin.png"></p><h2 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h2><p>浏览器将CORS请求分为两类： <strong>简单请求</strong>和<strong>非简单请求</strong>。</p><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。<br>例如，下面的前端代码向后台发送了一个非简单请求，因为它制定了’Content-type’: ‘application/json’<br><img src="/blog/img/20180309/2.png" srcset="/blog/img/loading.gif" alt="code.png"></p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求。</p><p>预检请求的请求方法是OPTIONS,请求的头信息包括两个特殊字段:</p><ul><li>Access-Control-Request-Method<br>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。</li><li>Access-Control-Request-Headers<br>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。</li></ul><p>服务器回应的其他CORS相关字段：</p><ul><li>Access-Control-Allow-Methods<br>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</li><li>Access-Control-Allow-Headers<br>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</li><li>Access-Control-Max-Age<br>该字段可选，用来指定本次预检请求的有效期，单位为秒。在此期间，不用发出另一条预检请求。<br><img src="/blog/img/20180309/3.png" srcset="/blog/img/loading.gif" alt="AccessControl.png"></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
