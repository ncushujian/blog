<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.png">
  <link rel="icon" type="image/png" href="/blog/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="shujian">
  <meta name="keywords" content="">
  <title>2019前端面试题汇总（一年经验) - ncushujian</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/blog/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/blog/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>ncushujian's space</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/blog/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                2019前端面试题汇总（一年经验)
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2019-05-26 00:00">
      2019年5月26日 凌晨
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      104
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h3 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h3><p>跳槽是为了得到更高的薪酬，或者为了寻找更具发展空间的公司一种常见的行为。我也于今年完成了一次跳槽，自然也有很多的感悟，作成本文供大家参考。<br> 本文主要分成两个部分，一部分是我自己整理的面试大纲，另外一部分是面试官考察的问题。</p>
<h3 id="面试大纲"><a href="#面试大纲" class="headerlink" title="面试大纲"></a>面试大纲</h3><blockquote>
<p>关于面试大纲，我认为每个人都是千差万别的。因为面试官都是对简历所写的项目经验进行深挖或者对你所掌握的基本技能进行考察。<br>我在简历上写的技能点包含了<code>HTML</code>/<code>CSS</code>/<code>JavaScript</code>/<code>ES6</code>/<code>HTTP协议</code>/<code>Vue</code>/<code>微信小程序</code>/<code>Node</code>/<code>Express</code>/<code>MySQL</code>/ <code>面向对象</code>/<code>设计模式</code><br>根据以上，整理出面试大纲</p>
</blockquote>
<h4 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h4><h5 id="lt-li-gt-标签之间有空格怎么处理？"><a href="#lt-li-gt-标签之间有空格怎么处理？" class="headerlink" title="&lt;li&gt;标签之间有空格怎么处理？"></a>&lt;li&gt;标签之间有空格怎么处理？</h5><p>原因：行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0或者将&lt;li&gt;标签写在一排，就没有空格了。</p>
<h4 id="二、CSS"><a href="#二、CSS" class="headerlink" title="二、CSS"></a>二、CSS</h4><h5 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h5><ol>
<li>支持rgba和透明度</li>
<li>支持媒体查询</li>
<li>支持自定义字体</li>
<li>对长的不可分割单词换行<code>word-wrap：break-word;</code></li>
<li>文字阴影<code>text-shadow: 5px 5px 5px #ff0000;</code></li>
<li>盒阴影<code>box-shadow: 10px 10px 5px #888888</code></li>
<li>支持圆角<code>border-radius: 50%;</code></li>
<li>边框图片<code>border-image: url(border.png) 30 30 round</code><h5 id="CSS优先级如何计算？"><a href="#CSS优先级如何计算？" class="headerlink" title="CSS优先级如何计算？"></a>CSS优先级如何计算？</h5></li>
</ol>
<ul>
<li>元素和伪元素：1</li>
<li>类选择器、属性选择器或伪类：10</li>
<li>id选择符：100</li>
<li>内联样式：1000</li>
</ul>
<ol>
<li>!important声明的样式优先级最高，如果冲突再进行计算。</li>
<li>继承得到的样式的优先级最低。</li>
<li>如果优先级相同，则选择最后出现的样式。</li>
</ol>
<h5 id="清除浮动的几种方式和各自的优缺点"><a href="#清除浮动的几种方式和各自的优缺点" class="headerlink" title="清除浮动的几种方式和各自的优缺点"></a>清除浮动的几种方式和各自的优缺点</h5><ol>
<li>添加空div，使用<code>clear: both;</code>缺点：进行清除浮动；会添加很多无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦；</li>
<li>父元素使用<code>overflow: hidden;</code>缺点：不能配合<code>position</code>一起使用，超出的部分会被隐藏；</li>
<li>父元素使用<code>overflow: auto;</code>缺点：超出部分会出现滚动条；</li>
<li>父级定义高度</li>
<li>推荐使用的方法：父级div定义伪类:after和zoom<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
<span class="css"><span class="hljs-selector-class">.clearfloat</span> &#123;</span>
    *zoom: 1;
&#125;
<span class="css"><span class="hljs-selector-class">.clearfloat</span><span class="hljs-selector-pseudo">:after</span> &#123;</span>
    content: "";
    height: 0;
    display: block;
    clear: both;
    visibility: hidden;
&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-comment">&lt;!-- *是为了兼容低版本IE7浏览器 zoom是ie属性，设置缩放比例 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box clearfloat"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<h5 id="如何水平居中一个浮动元素？"><a href="#如何水平居中一个浮动元素？" class="headerlink" title="如何水平居中一个浮动元素？"></a>如何水平居中一个浮动元素？</h5><pre><code class="hljs scss"><span class="hljs-selector-id">#test</span> &#123;
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
  <span class="hljs-attribute">background-color</span>: green;
  &lt;!-- 三行代码缺一不可 --&gt;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;
&#125;</code></pre>
<pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"test"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre>
<h5 id="如何水平居中一个浮动元素？-1"><a href="#如何水平居中一个浮动元素？-1" class="headerlink" title="如何水平居中一个浮动元素？"></a>如何水平居中一个浮动元素？</h5><pre><code class="hljs scss"><span class="hljs-selector-id">#test</span> &#123;
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
  <span class="hljs-attribute">background-color</span>: green;
  &lt;!-- 三行代码缺一不可 --&gt;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;
&#125;</code></pre>
<pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"test"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre>
<h5 id="利用CSS画三角形"><a href="#利用CSS画三角形" class="headerlink" title="利用CSS画三角形"></a>利用CSS画三角形</h5><pre><code class="hljs css"><span class="hljs-selector-id">#triangle</span> &#123;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">40px</span> solid transparent;
  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">40px</span> solid transparent;
  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">40px</span> solid transparent;
  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">40px</span> solid greenyellow;
&#125;</code></pre>
<pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"triangle"</span>&gt;&lt;<span class="hljs-keyword">div</span>&gt;</code></pre>
<h5 id="display-none-和-visibility-hidden-的区别？"><a href="#display-none-和-visibility-hidden-的区别？" class="headerlink" title="display: none; 和 visibility: hidden; 的区别？"></a><code>display: none;</code> 和 <code>visibility: hidden;</code> 的区别？</h5></li>
<li><code>display：none;</code> 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</li>
<li><code>visibility：hidden;</code> 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</li>
</ol>
<h5 id="position-和-float-值相互叠加会发生什么？"><a href="#position-和-float-值相互叠加会发生什么？" class="headerlink" title="position 和 float 值相互叠加会发生什么？"></a><code>position</code> 和 <code>float</code> 值相互叠加会发生什么？</h5><p><code>position：absolute/fixed;</code> 优先级最高，有他们在时，<code>float</code>不起作用，<code>display</code>值需要调整。</p>
<h5 id="对BFC规范-块级格式化上下文：block-formatting-context-的理解？"><a href="#对BFC规范-块级格式化上下文：block-formatting-context-的理解？" class="headerlink" title="对BFC规范(块级格式化上下文：block formatting context)的理解？"></a>对BFC规范(块级格式化上下文：block formatting context)的理解？</h5><p>BFC规定了内部的Block Box如何布局。<br>定位方案：</p>
<ol>
<li>内部的Box会在垂直方向上一个接一个放置。</li>
<li>Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。</li>
<li>每个元素的margin box 的左边，与包含块border box的左边相接触。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</li>
<li>计算BFC的高度时，浮动元素也会参与计算。</li>
</ol>
<p>满足下列条件之一就可触发BFC</p>
<ol>
<li><p>根元素，即html</p>
</li>
<li><p>float的值不为none（默认）</p>
</li>
<li><p>overflow的值不为visible（默认）</p>
</li>
<li><p>display的值为inline-block、table-cell、table-caption</p>
</li>
<li><p>position的值为absolute或fixed</p>
<h5 id="为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"><a href="#为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？" class="headerlink" title="为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"></a>为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</h5><p>浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。<br>浮动带来的问题：</p>
</li>
<li><p>父元素的高度无法被撑开，影响与父元素同级的元素</p>
</li>
<li><p>与浮动元素同级的非浮动元素（内联元素）会跟随其后</p>
</li>
<li><p>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。</p>
</li>
</ol>
<p>清除浮动的方式：</p>
<ol>
<li>父级div定义height</li>
<li>最后一个浮动元素后加空div标签 并添加样式clear:both。</li>
<li>包含浮动元素的父标签添加样式overflow为hidden或auto。</li>
<li>父级div定义zoom<h5 id="after和-after的区别是什么？"><a href="#after和-after的区别是什么？" class="headerlink" title=":after和::after的区别是什么？"></a><code>:after</code>和<code>::after</code>的区别是什么？</h5></li>
<li>在CSS3的规范里<code>:</code>表示伪类，<code>::</code>表示伪元素</li>
<li><code>:after</code>在CSS2.1的规范中，表示伪元素，随着WEB的发展，在CSS3的规范中，伪元素的语法被修改成使用双冒号，成为<code>::after</code><h5 id="实现一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度"><a href="#实现一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度" class="headerlink" title="实现一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度"></a>实现一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</h5><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> &#123;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
&#125;
<span class="hljs-selector-id">#box</span> &#123;
  <span class="hljs-attribute">position</span>: relative;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
  <span class="hljs-attribute">background-color</span>: beige;
&#125;
<span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.block-1</span> &#123;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
  <span class="hljs-attribute">background-color</span>: rosybrown;
&#125;
<span class="hljs-selector-id">#box</span> <span class="hljs-selector-class">.block-2</span> &#123;
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">100px</span>;
  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
  <span class="hljs-attribute">background-color</span>: red;
&#125;</code></pre>
<pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"box"</span>&gt;
  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"block-1"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;
  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"block-2"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;
&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre>
<h4 id="三、JavaScript"><a href="#三、JavaScript" class="headerlink" title="三、JavaScript"></a>三、JavaScript</h4><h5 id="简单说说继承的方式和优缺点？"><a href="#简单说说继承的方式和优缺点？" class="headerlink" title="简单说说继承的方式和优缺点？"></a>简单说说继承的方式和优缺点？</h5><h6 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h6><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>&#123; 
    <span class="hljs-keyword">this</span>.name = name;
&#125;
Parent.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent name:'</span>, <span class="hljs-keyword">this</span>.name);
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name</span>) </span>&#123;
    <span class="hljs-keyword">this</span>.name = name;
&#125;
Child.prototype = <span class="hljs-keyword">new</span> Parent(<span class="hljs-string">'father'</span>);
Child.prototype.constructor = Child;
Child.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child name:'</span>, <span class="hljs-keyword">this</span>.name);
&#125;
<span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">'son'</span>);
child.sayName();    <span class="hljs-comment">// child name: son</span>
<span class="hljs-comment">// 这种方法存在两个缺陷：</span>
<span class="hljs-comment">// 1.子类型无法给超类型传递参数，在面向对象的继承中，我们总希望通过 var child = new Child('son', 'father'); 让子类去调用父类的构造器来完成继承。而不是通过像这样 new Parent('father') 去调用父类。</span>
<span class="hljs-comment">// 2.Child.prototype.sayName 必须写在 Child.prototype = new Parent('father') 之后，不然就会被覆盖掉。</span></code></pre>
<h6 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h6><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>&#123; 
    <span class="hljs-keyword">this</span>.name = name;
&#125;
Parent.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent name:'</span>, <span class="hljs-keyword">this</span>.name);
&#125;
Parent.prototype.doSomthing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent do something!'</span>);
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name, parentName</span>) </span>&#123;
    Parent.call(<span class="hljs-keyword">this</span>, parentName);
    <span class="hljs-keyword">this</span>.name = name;
&#125;
Child.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child name:'</span>, <span class="hljs-keyword">this</span>.name);
&#125;
<span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">'son'</span>);
child.sayName();      <span class="hljs-comment">// child name: son</span>
child.doSomthing();   <span class="hljs-comment">// TypeError: child.doSomthing is not a function</span>
<span class="hljs-comment">// 解决了原型链继承带来的问题</span>
<span class="hljs-comment">// 但存在缺陷：每次创建一个 Child 实例对象时候都需要执行一遍 Parent 函数，无法复用一些公用函数。</span></code></pre>
<h6 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h6><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>&#123; 
    <span class="hljs-keyword">this</span>.name = name;
&#125;
Parent.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent name:'</span>, <span class="hljs-keyword">this</span>.name);
&#125;
Parent.prototype.doSomething = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent do something!'</span>);
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name, parentName</span>) </span>&#123;
    Parent.call(<span class="hljs-keyword">this</span>, parentName);      <span class="hljs-comment">// 第二次调用</span>
    <span class="hljs-keyword">this</span>.name = name;
&#125;

Child.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child name:'</span>, <span class="hljs-keyword">this</span>.name);
&#125;
Child.prototype = <span class="hljs-keyword">new</span> Parent();         <span class="hljs-comment">// 第一次调用</span>
Child.prototype.construtor = Child;
<span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">'son'</span>);
child.sayName();      
child.doSomething(); 
<span class="hljs-comment">// 第一次调用构造函数显然是没有必要的，因为第一次调用构造函数时候不需要函数内部的那些实例属性，这么写只是想获得其原型上的方法罢了</span>
<span class="hljs-comment">// 下面的寄生组合式继承解决了这个问题</span></code></pre>
<h6 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h6><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>&#123;
    <span class="hljs-keyword">this</span>.name = name;
&#125;
Parent.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent name:'</span>, <span class="hljs-keyword">this</span>.name);
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name, parentName</span>) </span>&#123;
    Parent.call(<span class="hljs-keyword">this</span>, parentName);  
    <span class="hljs-keyword">this</span>.name = name;    
&#125;
Child.prototype = <span class="hljs-built_in">Object</span>.create(Parent.prototype);   <span class="hljs-comment">//修改</span>
Child.prototype.construtor = Child;
Child.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child name:'</span>, <span class="hljs-keyword">this</span>.name);
&#125;
<span class="hljs-keyword">var</span> parent = <span class="hljs-keyword">new</span> Parent(<span class="hljs-string">'father'</span>);
parent.sayName();      <span class="hljs-comment">// parent name: father</span>
<span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">'son'</span>, <span class="hljs-string">'father'</span>);
child.sayName();       <span class="hljs-comment">// child name: son</span></code></pre>
<pre><code class="hljs javascript"><span class="hljs-comment">// tips:</span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment">  Object.create(proto, [propertiesObject])</span>
<span class="hljs-comment">  Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__</span>
<span class="hljs-comment">  </span>
<span class="hljs-comment">  proto</span>
<span class="hljs-comment">    新创建对象的原型对象。</span>
<span class="hljs-comment">  propertiesObject 可选。</span>
<span class="hljs-comment">    如果没有指定为undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。</span>
<span class="hljs-comment">  </span>
<span class="hljs-comment">*/</span></code></pre>
<h5 id="谈谈JS中的this"><a href="#谈谈JS中的this" class="headerlink" title="谈谈JS中的this"></a>谈谈JS中的<code>this</code></h5></li>
<li><code>this</code>是在执行上下文创建时确定的一个在执行过程中不可更改的变量</li>
<li><code>this</code>只在函数调用阶段确定，也就是执行上下文创建的阶段进行赋值，保存在变量对象中。<blockquote>
<p><strong>执行上下文</strong>，就是JavaScript引擎在执行一段代码之前将代码内部会用到的一些<code>变量</code>、<code>函数</code>、<code>this</code>提前声明然后保存在变量对象中的过程。</p>
</blockquote>
<h5 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h5></li>
<li>()括号 .成员访问</li>
<li>()函数调用 new</li>
<li>++ – !</li>
<li>*  %</li>
<li>+ -</li>
<li>&gt;= &lt;= &gt; &lt;</li>
<li>== !==</li>
<li>&amp; ^ | 位运算符</li>
<li>&amp;&amp; || 逻辑运算符</li>
<li>a ? x : y 条件运算符</li>
<li>= op = 运算赋值<pre><code class="hljs javascript"><span class="hljs-comment">// 本题的涉及考点主要还是运算符的优先级</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;
  getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
&#125;
Foo.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)
&#125;
Foo.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)
&#125;
<span class="hljs-keyword">var</span> getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)
&#125;

<span class="hljs-comment">// 写出以下函数的执行结果</span>
Foo.getName()            <span class="hljs-comment">// 2</span>
getName()                <span class="hljs-comment">// 4</span>
Foo().getName()          <span class="hljs-comment">// 1  </span>
getName()                <span class="hljs-comment">// 1</span>
<span class="hljs-keyword">new</span> Foo.getName()        <span class="hljs-comment">// 2</span>
<span class="hljs-comment">// new (Foo.getName)()</span>
<span class="hljs-keyword">new</span> Foo().getName()      <span class="hljs-comment">// 3</span>
<span class="hljs-comment">// (new Foo()).getName()</span>
<span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> Foo().getName()  <span class="hljs-comment">// 3</span>
<span class="hljs-comment">// new((new Foo()).getName)()</span></code></pre>
<h5 id="简单聊一聊包装对象？"><a href="#简单聊一聊包装对象？" class="headerlink" title="简单聊一聊包装对象？"></a>简单聊一聊包装对象？</h5><code>引用类型</code>和<code>包装对象</code>的区别在于<strong>生存期</strong><br>引用类型所创建的对象会一直存在于堆内存中，而基本包装对象只存在于一瞬间<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">'hello'</span>;
str.number = <span class="hljs-number">10</span>;   <span class="hljs-comment">//假设我们想给字符串添加一个属性number ，后台会有如下步骤</span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment">  var str = new String('hello'); // 1 找到对应的包装对象类型，然后通过包装对象创建出一个和基本类型值相同的对象</span>
<span class="hljs-comment">  str.number = 10; // 2 通过这个对象调用包装对象下的方法 但结果并没有被任何东西保存</span>
<span class="hljs-comment">  str =null; // 3 这个对象又被销毁</span>
<span class="hljs-comment">*/</span>
alert(str.number); <span class="hljs-comment">//undefined  当执行到这一句的时候，因为基本类型本来没有属性，后台又会重新重复上面的步骤</span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment"> var str = new String('hello'); // 1 找到基本包装对象，然后又新开辟一个内存，创建一个值为hello对象</span>
<span class="hljs-comment"> str.number = undefined   // 2 因为包装对象下面没有number这个属性，所以又会重新添加，因为没有值，所以值是未定 ;然后弹出结果</span>
<span class="hljs-comment"> str =null; // 3 这个对象又被销毁</span>
<span class="hljs-comment">*/</span></code></pre>
<h5 id="instanceof-和-typeof"><a href="#instanceof-和-typeof" class="headerlink" title="instanceof 和 typeof"></a>instanceof 和 typeof</h5><code>instanceof</code>运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置（Instanceof 的使用规则是： <code>A instanceof B</code> A沿着proto这条线来找，同时B沿着prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。）<h5 id="函数-变量提升"><a href="#函数-变量提升" class="headerlink" title="函数/变量提升"></a>函数/变量提升</h5><pre><code class="hljs javascript"><span class="hljs-comment">// 1、函数提升优先级高于变量提升</span>
<span class="hljs-comment">// 2、表达式可以修改提升后变量的值</span>

test() <span class="hljs-comment">// 2</span>
<span class="hljs-keyword">var</span> test = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)
&#125;
test() <span class="hljs-comment">// 1</span>
  
alert(a);
<span class="hljs-keyword">var</span> a=<span class="hljs-number">1</span>;
alert(a); 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;alert(<span class="hljs-number">2</span>)&#125;;
alert(a);
<span class="hljs-keyword">var</span> a=<span class="hljs-number">3</span>;
alert(a);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;alert(<span class="hljs-number">4</span>)&#125;;
alert(a);
a();

<span class="hljs-comment">// function a() &#123;alert (4)&#125;; </span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 报错</span></code></pre>
<h5 id="new-操作符都干了些什么？"><a href="#new-操作符都干了些什么？" class="headerlink" title="new 操作符都干了些什么？"></a>new 操作符都干了些什么？</h5><pre><code class="hljs javascript"><span class="hljs-comment">// new共经历了四个阶段</span>
<span class="hljs-comment">// 1、创建一个空对象</span>
<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()
<span class="hljs-comment">// 2、设置原型链</span>
obj.__proto__ = Func.prototype
<span class="hljs-comment">// 3、让Func中的this指向obj，并执行Func的函数体</span>
<span class="hljs-keyword">var</span> result = Func.call(obj)
<span class="hljs-comment">// 4、判断Func的返回值类型</span>
<span class="hljs-comment">// 如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象</span>
<span class="hljs-comment">// (tip: 构造函数默认 return this，不用写)</span>
<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'object'</span>) &#123;
    <span class="hljs-keyword">return</span> result
&#125; eles &#123;
    <span class="hljs-keyword">return</span> obj
&#125;</code></pre>
<h4 id="四、Vue"><a href="#四、Vue" class="headerlink" title="四、Vue"></a>四、Vue</h4><h5 id="对MVVM的理解"><a href="#对MVVM的理解" class="headerlink" title="对MVVM的理解"></a>对MVVM的理解</h5>MVVM分为Model、View、ViewModel三者<br></li>
</ol>
<p><code>Model</code> 代表数据模型，数据和业务逻辑都在Model层中定义；<br><code>View</code> 代表UI视图，负责数据的展示；<br><code>ViewModel</code> 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；</p>
<p>Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。<br>这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom</p>
<h5 id="Vue的双向数据绑定是如何实现的？"><a href="#Vue的双向数据绑定是如何实现的？" class="headerlink" title="Vue的双向数据绑定是如何实现的？"></a>Vue的双向数据绑定是如何实现的？</h5><p>简单来说就是使用<code>数据劫持</code>和<code>发布订阅的设计模式</code>实现的</p>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>MVVM双向数据绑定<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vue</span> </span>&#123;</span>
<span class="javascript">      <span class="hljs-keyword">constructor</span>(options) &#123;</span>
<span class="actionscript">        <span class="hljs-keyword">this</span>.options = options</span>
<span class="actionscript">        <span class="hljs-keyword">this</span>.$data = options.data</span>
<span class="javascript">        <span class="hljs-keyword">this</span>.$el = <span class="hljs-built_in">document</span>.querySelector(options.el)</span>
<span class="actionscript">        <span class="hljs-keyword">this</span>._directives = &#123;&#125;;</span>
<span class="actionscript">        <span class="hljs-comment">// 数据劫持</span></span>
<span class="actionscript">        <span class="hljs-keyword">this</span>.Observer(<span class="hljs-keyword">this</span>.$data)</span>
<span class="actionscript">        <span class="hljs-comment">// 解析指令</span></span>
<span class="actionscript">        <span class="hljs-keyword">this</span>.Compile(<span class="hljs-keyword">this</span>.$el)</span>
      &#125;
      Observer(data) &#123;
<span class="javascript">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> data) &#123;</span>
<span class="actionscript">          <span class="hljs-keyword">this</span>._directives[key] = []</span>
<span class="javascript">          <span class="hljs-keyword">let</span> val = data[key]</span>
<span class="javascript">          <span class="hljs-keyword">let</span> _obj = <span class="hljs-keyword">this</span>._directives[key]</span>
<span class="javascript">          <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>.$data, key, &#123;</span>
<span class="actionscript">            <span class="hljs-keyword">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;</span>
<span class="actionscript">              <span class="hljs-keyword">return</span> val</span>
            &#125;,
<span class="actionscript">            <span class="hljs-keyword">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(newVal)</span> </span>&#123;</span>
              if(val !== newVal) &#123;
                val = newVal
<span class="javascript">                _obj.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;</span>
                  item.update()
                &#125;)
              &#125;
            &#125;
          &#125;)
        &#125;
      &#125;
      Compile(el) &#123;
<span class="javascript">        <span class="hljs-keyword">let</span> nodes = el.children</span>
<span class="javascript">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;nodes.length; i++) &#123;</span>
<span class="javascript">          <span class="hljs-keyword">let</span> node = nodes[i]</span>
          if(node.children.length) &#123;
<span class="actionscript">            <span class="hljs-keyword">this</span>.Compile(node)</span>
          &#125;
<span class="actionscript">          <span class="hljs-keyword">if</span>(node.hasAttribute(<span class="hljs-string">'v-text'</span>)) &#123;</span>
<span class="javascript">            <span class="hljs-keyword">let</span> attrValue = node.getAttribute(<span class="hljs-string">"v-text"</span>);</span>
<span class="actionscript">            <span class="hljs-keyword">this</span>._directives[attrValue].push(<span class="hljs-keyword">new</span> Watch(node, <span class="hljs-keyword">this</span>, attrValue, <span class="hljs-string">"innerHTML"</span>))</span>
          &#125;
<span class="actionscript">          <span class="hljs-keyword">if</span>(node.hasAttribute(<span class="hljs-string">'v-model'</span>)) &#123;</span>
<span class="javascript">            <span class="hljs-keyword">let</span> _this = <span class="hljs-keyword">this</span></span>
<span class="javascript">            <span class="hljs-keyword">let</span> attrValue = node.getAttribute(<span class="hljs-string">"v-model"</span>);</span>
<span class="actionscript">            <span class="hljs-keyword">this</span>._directives[attrValue].push(<span class="hljs-keyword">new</span> Watch(node, <span class="hljs-keyword">this</span>, attrValue, <span class="hljs-string">"value"</span>))</span>

<span class="actionscript">            node.addEventListener(<span class="hljs-string">'input'</span>, (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;</span>
<span class="actionscript">              <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;</span>
                _this.$data[attrValue] = node.value
              &#125;
            &#125;)())
          &#125;
        &#125;
      &#125;
    &#125;

<span class="actionscript">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watch</span> </span>&#123;</span>
<span class="javascript">      <span class="hljs-keyword">constructor</span>(el, vm, exp, attr) &#123;</span>
<span class="actionscript">        <span class="hljs-keyword">this</span>.el = el</span>
<span class="actionscript">        <span class="hljs-keyword">this</span>.vm = vm</span>
<span class="actionscript">        <span class="hljs-keyword">this</span>.exp = exp</span>
<span class="actionscript">        <span class="hljs-keyword">this</span>.attr = attr</span>
<span class="actionscript">        <span class="hljs-keyword">this</span>.update()</span>
      &#125;
      update() &#123;
<span class="actionscript">        <span class="hljs-keyword">this</span>.el[<span class="hljs-keyword">this</span>.attr] = <span class="hljs-keyword">this</span>.vm.$data[<span class="hljs-keyword">this</span>.exp]</span>
      &#125;
    &#125;
  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>数据双向绑定<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">"myText"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"myText"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">    <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span>
<span class="actionscript">      el: <span class="hljs-string">'#app'</span>,</span>
      data: &#123;
<span class="actionscript">        myText: <span class="hljs-string">'今晚吃鸡呐，大吉大利！'</span></span>
      &#125;
    &#125;);
  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<h5 id="Vue如何监听某个属性值的变化"><a href="#Vue如何监听某个属性值的变化" class="headerlink" title="Vue如何监听某个属性值的变化"></a>Vue如何监听某个属性值的变化</h5><pre><code class="hljs javascript">watch: &#123;
  <span class="hljs-string">'obj.a'</span>: &#123;
    handler (newName, oldName) &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'obj.a changed'</span>)
    &#125;
  &#125;
&#125;

computed: &#123;
  a1 () &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.obj.a
  &#125;
&#125;</code></pre>

<h5 id="Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决"><a href="#Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决" class="headerlink" title="Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决?"></a>Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决?</h5><p>数据已经添加，但是视图并没有刷新；<br><br>原因在于在Vue实例创建时，<code>obj.b</code>并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局api <code>Vue.$set()</code></p>
<pre><code class="hljs javascript">addObjB () &#123;
  <span class="hljs-comment">// this.obj.b = 'obj.b'</span>
  <span class="hljs-keyword">this</span>.$<span class="hljs-keyword">set</span>(this.obj, 'b', 'obj.b')
  console.log(this.obj)
&#125;</code></pre>
<h5 id="Vue组件通讯的方式"><a href="#Vue组件通讯的方式" class="headerlink" title="Vue组件通讯的方式"></a>Vue组件通讯的方式</h5><ol>
<li>父子组件通讯：父-&gt;子：使用props，子-&gt;父：$emit方法传递参数</li>
<li>使用eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件</li>
<li>Vuex<blockquote>
<p>可以去掘金找这类文章看一下，Vue组件的通讯方式达6种之多</p>
</blockquote>
</li>
</ol>
<h5 id="Vue常用的修饰符"><a href="#Vue常用的修饰符" class="headerlink" title="Vue常用的修饰符"></a>Vue常用的修饰符</h5><p><code>.prevent</code>: 提交事件不再重载页面；<br><code>.stop</code>: 阻止单击事件冒泡；<br><code>.self</code>: 当事件发生在该元素本身而不是子元素的时候会触发；<br><code>.capture</code>: 事件侦听，事件发生的时候会调用；</p>
<h5 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和 $router 的区别"></a>$route 和 $router 的区别</h5><p><strong>$route</strong> 是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数<br><strong>$router</strong> 是“路由实例”对象包括了路由的跳转方法，钩子函数等</p>
<h5 id="Vue的路由实现：hash模式-和-history模式"><a href="#Vue的路由实现：hash模式-和-history模式" class="headerlink" title="Vue的路由实现：hash模式 和 history模式"></a>Vue的路由实现：hash模式 和 history模式</h5><p><strong>hash模式：</strong> 在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；<br>特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。<br>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a href="http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回" target="_blank" rel="noopener">http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回</a> 404 错误。</p>
<p><strong>history模式：</strong> history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。<br>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <a href="http://www.xxx.com/items/id。后端如果缺少对" target="_blank" rel="noopener">http://www.xxx.com/items/id。后端如果缺少对</a> /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</p>
<h5 id="对keep-alive的了解？"><a href="#对keep-alive的了解？" class="headerlink" title="对keep-alive的了解？"></a>对keep-alive的了解？</h5><p><strong>keep-alive</strong>是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染<br>在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。</p>
<h5 id="delete和Vue-delete删除数组的区别？"><a href="#delete和Vue-delete删除数组的区别？" class="headerlink" title="delete和Vue.delete删除数组的区别？"></a>delete和Vue.delete删除数组的区别？</h5><p>delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变；<br>Vue.delete直接删除了数组 改变了数组的键值。</p>
<h5 id="如何优化SPA应用的首屏加载速度慢的问题？"><a href="#如何优化SPA应用的首屏加载速度慢的问题？" class="headerlink" title="如何优化SPA应用的首屏加载速度慢的问题？"></a>如何优化SPA应用的首屏加载速度慢的问题？</h5><ol>
<li>将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；</li>
<li>在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；</li>
<li>加一个首屏 loading 图，提升用户体验；</li>
</ol>
<h5 id="Vuex是什么？如何使用？哪种场景使用它？"><a href="#Vuex是什么？如何使用？哪种场景使用它？" class="headerlink" title="Vuex是什么？如何使用？哪种场景使用它？"></a>Vuex是什么？如何使用？哪种场景使用它？</h5><p>将需要读取的状态集中放在<code>store</code>中<br>改变状态的方式是提交<code>mutations</code>，这是一个同步的事务<br>异步逻辑应该封装在<code>actions</code>中</p>
<p><strong>state</strong> Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。<br><strong>mutations</strong> 定义的方法动态修改<code>Vuex</code>的<code>store</code>中的状态或数据。<br><strong>getters</strong> 类似<code>vue</code>的计算属性，主要用来过滤一些数据。<br><strong>action</strong> 可以理解为通过将<code>mutations</code>里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view层通过<code>store.dispath</code>来分发<code>action</code><br><strong>modules</strong> 项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理</p>
<h5 id="Vue等单页应用的优缺点"><a href="#Vue等单页应用的优缺点" class="headerlink" title="Vue等单页应用的优缺点"></a>Vue等单页应用的优缺点</h5><p>优点：Vue的目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件，核心是<strong>响应式系统</strong>。<br>缺点：不支持低版本浏览器，最低仅支持ie9；不利于SEO的优化，首页加载耗时相对偏长一些。</p>
<h4 id="五、ES6"><a href="#五、ES6" class="headerlink" title="五、ES6"></a>五、ES6</h4><h5 id="let和var的区别"><a href="#let和var的区别" class="headerlink" title="let和var的区别"></a><code>let</code>和<code>var</code>的区别</h5><ol>
<li>不存在变量提升</li>
<li>暂时性的死区<pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;
  <span class="hljs-comment">// --- 死区开始 ---</span>
  tmp = <span class="hljs-string">'abc'</span>; <span class="hljs-comment">// ReferenceError</span>
  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// ReferenceError</span>

  <span class="hljs-keyword">let</span> tmp;
  <span class="hljs-comment">// --- 死区结束 ---</span>
  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// undefined</span>

  tmp = <span class="hljs-number">123</span>;
  <span class="hljs-built_in">console</span>.log(tmp); <span class="hljs-comment">// 123</span>
&#125;</code></pre></li>
<li><code>let</code>为JavaScript新增了块级作用域<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
  a[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(i);
  &#125;;
&#125;
a[<span class="hljs-number">6</span>](); <span class="hljs-comment">// 10</span>
<span class="hljs-comment">// 变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i，每一次循环，变量i的值都会发生改变</span>

<span class="hljs-keyword">var</span> a = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
  a[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(i);
  &#125;;
&#125;
a[<span class="hljs-number">6</span>](); <span class="hljs-comment">// 6</span>
<span class="hljs-comment">// 变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。</span></code></pre>
<h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5>定义：从数组或对象中提取值，对变量进行赋值</li>
<li>数组的解构赋值<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-keyword">let</span> [ , , third] = [<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>, <span class="hljs-string">"baz"</span>];
third <span class="hljs-comment">// "baz"</span>

<span class="hljs-keyword">let</span> [x, , y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
x <span class="hljs-comment">// 1</span>
y <span class="hljs-comment">// 3</span>

<span class="hljs-keyword">let</span> [head, ...tail] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
head <span class="hljs-comment">// 1</span>
tail <span class="hljs-comment">// [2, 3, 4]</span>

<span class="hljs-keyword">let</span> [x, y, ...z] = [<span class="hljs-string">'a'</span>];
x <span class="hljs-comment">// "a"</span>
y <span class="hljs-comment">// undefined</span>
z <span class="hljs-comment">// []</span>

<span class="hljs-keyword">let</span> [x, y = <span class="hljs-number">10</span>] = [<span class="hljs-number">7</span>]</code></pre></li>
<li>对象的解构赋值<br><br>（tip: 数组的解构赋值对顺序有要求，而对象则没有要求，变量必须与属性同名，才能取到正确的值）<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">'aaa'</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">'bbb'</span> &#125;;
foo <span class="hljs-comment">// "aaa"</span>
bar <span class="hljs-comment">// "bbb"</span>

<span class="hljs-keyword">let</span> &#123; baz &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">'aaa'</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">'bbb'</span> &#125;;
baz <span class="hljs-comment">// undefined</span>

<span class="hljs-keyword">var</span> &#123;x, y = <span class="hljs-number">5</span>&#125; = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;;

<span class="hljs-comment">// 如果变量名与属性名不一致，必须写成下面这样。</span>
<span class="hljs-comment">// foo 是模式， baz 才是变量，特别要注意区分模式和变量</span>
<span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">foo</span>: baz &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">'aaa'</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">'bbb'</span> &#125;;</code></pre></li>
<li>嵌套解构赋值<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;
  p: [
    <span class="hljs-string">'Hello'</span>,
    &#123; <span class="hljs-attr">y</span>: <span class="hljs-string">'World'</span> &#125;
  ]
&#125;;

<span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">p</span>: [x, &#123; y &#125;] &#125; = obj;
x <span class="hljs-comment">// "Hello"</span>
y <span class="hljs-comment">// "World"</span>

<span class="hljs-comment">// p 是模式，不会被复制，若想被赋值，可以写成如下形式</span>
<span class="hljs-keyword">let</span> &#123; p, <span class="hljs-attr">p</span>: [x, &#123; y &#125;] &#125; = obj;
x <span class="hljs-comment">// "Hello"</span>
y <span class="hljs-comment">// "World"</span>
p <span class="hljs-comment">// ["Hello", &#123;y: "World"&#125;]</span></code></pre>
<h5 id="箭头函数和非箭头函数的区别"><a href="#箭头函数和非箭头函数的区别" class="headerlink" title="箭头函数和非箭头函数的区别"></a>箭头函数和非箭头函数的区别</h5></li>
<li>箭头函数的<code>this</code>指向在定义的时候继承自外层的第一个普通函数的<code>this</code>，若外层没有普通函数，指向的是<code>window</code></li>
<li>不能直接修改箭头函数的<code>this</code>指向</li>
<li>箭头函数的this指向全局，使用<code>arguments</code>会报未声明的错误。</li>
<li>箭头函数的this指向普通函数时,它的<code>argumens</code>继承于该普通函数</li>
<li>使用<code>new</code>调用箭头函数会报错，因为箭头函数没有<code>constructor</code></li>
</ol>
<h5 id="简单讲讲Promise"><a href="#简单讲讲Promise" class="headerlink" title="简单讲讲Promise"></a>简单讲讲Promise</h5><p><strong>Promise的特点</strong><br>状态一旦改变就再也不会发生改变了<br><strong>Promise的缺点</strong></p>
<ol>
<li>无法取消Promise，一旦新建它就会立即执行，无法中途取消；</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部；</li>
<li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ol>
<h5 id="如何创建Promise实例？"><a href="#如何创建Promise实例？" class="headerlink" title="如何创建Promise实例？"></a>如何创建Promise实例？</h5><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;
    resolve(value);
  &#125; <span class="hljs-keyword">else</span> &#123;
    reject(error);
  &#125;
&#125;);</code></pre>
<h5 id="简单讲讲Promise-API"><a href="#简单讲讲Promise-API" class="headerlink" title="简单讲讲Promise API"></a>简单讲讲Promise API</h5><ul>
<li>Promise.resolve();<pre><code class="hljs javascript"><span class="hljs-comment">// 1. 如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">resolve</span>)</span>&#123;
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
        resolve(<span class="hljs-number">123</span>);
    &#125;,<span class="hljs-number">3000</span>);
&#125;
<span class="hljs-keyword">let</span> p0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(fn);
<span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(p0);
<span class="hljs-comment">// 返回为true，返回的 Promise 即是 入参的 Promise 对象。</span>
<span class="hljs-built_in">console</span>.log(p0 === p1);

<span class="hljs-comment">//2. 如果这个值是个 thenable（thenable对象指的是具有then方法的对象），返回的 Promise 对象会“跟随”这个 thenable 的对象，采用它的最终状态（指 resolved/rejected/pending/settled）</span>
<span class="hljs-keyword">let</span> promise = <span class="hljs-built_in">Promise</span>.resolve($.ajax(<span class="hljs-string">'/test/test.json'</span>));<span class="hljs-comment">// =&gt; promise对象</span>
promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;
   <span class="hljs-built_in">console</span>.log(value);
&#125;);</code></pre></li>
<li>Promise.reject();</li>
<li>Promise.race<pre><code class="hljs javascript"><span class="hljs-comment">// 类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise</span>
<span class="hljs-comment">// 任务的结果，不管这个 Promise 结果是成功还是失败。 。</span></code></pre></li>
<li>Promise.all<pre><code class="hljs javascript"><span class="hljs-comment">// 类方法，多个 Promise 任务同时执行。</span>
<span class="hljs-comment">// 如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。</span>
<span class="hljs-comment">// 如果有一个 Promise 任务 rejected，则只返回 rejected 任务的结果。</span>
<span class="hljs-keyword">const</span> promises = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>&#123;
  <span class="hljs-keyword">return</span> getJSON(<span class="hljs-string">'/post/'</span> + id + <span class="hljs-string">".json"</span>);
&#125;);

<span class="hljs-built_in">Promise</span>.all(promises).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">posts</span>) </span>&#123;
  <span class="hljs-comment">// ...</span>
&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)</span>&#123;
  <span class="hljs-comment">// ...</span>
&#125;);</code></pre></li>
<li>Promise.prototype.then()</li>
<li>Promise.prototype.catch() 该方法可以捕获到then链上发生的任何一个错误</li>
<li>Promise.prototype.finally() 该方法用于指定不管 <code>Promise</code> 对象最后状态如何，都会执行的操作<pre><code class="hljs javascript">promise
.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;···&#125;)
.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;···&#125;)
.finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;
    <span class="hljs-comment">// finally方法的回调函数不接受任何参数，这意味着没有办法知道，</span>
    <span class="hljs-comment">//前面的 Promise 状态到底是fulfilled还是rejected。这表明，</span>
    <span class="hljs-comment">// finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</span>
&#125;);</code></pre>
关于<code>Promise</code>，不同面试官考察的深度因人而异，反正做好手写实现<code>Promise</code>的准备即可<h4 id="六、微信小程序"><a href="#六、微信小程序" class="headerlink" title="六、微信小程序"></a>六、微信小程序</h4><h5 id="简述微信小程序原理"><a href="#简述微信小程序原理" class="headerlink" title="简述微信小程序原理"></a>简述微信小程序原理</h5></li>
</ul>
<ol>
<li>小程序本质就是一个单页应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口；</li>
<li>功能可分为渲染层<code>webview</code>和逻辑层<code>appService</code>两个部分；<br><code>webview</code>用来展现UI，<code>appService</code>有来处理业务逻辑、数据及接口调用；<br>两个部分在两个进程中运行，通过系统层<code>JSBridge</code>实现通信，实现UI的渲染、事件的处理等。<h5 id="为什么微信小程序的DOM-API不完整？"><a href="#为什么微信小程序的DOM-API不完整？" class="headerlink" title="为什么微信小程序的DOM API不完整？"></a>为什么微信小程序的DOM API不完整？</h5>因为微信小程序的渲染线程和脚本线程是分开的，脚本线程独立在 <code>JSCore</code> 中，没有一个完整的浏览器对象。<h5 id="简单谈谈WXS"><a href="#简单谈谈WXS" class="headerlink" title="简单谈谈WXS?"></a>简单谈谈WXS?</h5>WXS(weixin script)，结合HTML，构建页面结构。<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">wxs</span> <span class="hljs-attr">module</span>=<span class="hljs-string">"m1"</span>&gt;</span>var msg = "hello world"; module.exports.message = msg;<span class="hljs-tag">&lt;/<span class="hljs-name">wxs</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;m1.message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></code></pre>
<h5 id="为什么setData操作会很昂贵？"><a href="#为什么setData操作会很昂贵？" class="headerlink" title="为什么setData操作会很昂贵？"></a>为什么setData操作会很昂贵？</h5></li>
</ol>
<p><strong>频繁用户交互的效果在小程序上表现是比较卡顿的，</strong> 例如页面有 2 个元素 A 和 B，用户在 A 上做 touchmove 手势，要求 B 也跟随移动。一次 <code>touchmove</code> 事件的响应过程为：</p>
<p>a、touchmove 事件从视图层（Webview）抛到逻辑层（App Service）<br>b、逻辑层（App Service）处理 touchmove 事件，再通过 setData 来改变 B 的位置</p>
<p>一次 touchmove 的响应需要经过 2 次的逻辑层和渲染层的通信以及一次渲染，通信(JSBridge)的耗时比较大。此外 setData 渲染也会阻塞其它脚本执行，导致了整个用户交互的动画过程会有延迟。</p>
<h5 id="谈谈小程序的生命周期函数"><a href="#谈谈小程序的生命周期函数" class="headerlink" title="谈谈小程序的生命周期函数"></a>谈谈小程序的生命周期函数</h5><p><strong>onLoad()</strong> 页面加载时触发，只会调用一次，可获取当前页面路径中的参数;<br><strong>onShow()</strong>  页面显示/切入前台时触发，一般用来发送数据请求(或者 set to foreground);<br><strong>onReady()</strong> 页面初次渲染完成时触发   只会调用一次，代表页面已可和视图层进行交互（当逻辑层通知渲染层 Send Initial Data，且渲染层 First Render 之后调用）；<br><strong>onHide()</strong> 页面隐藏/切入后台时触发(set to background)， 如底部tab切换到其他页面或小程序切入后台等；<br><strong>onUnload()</strong> 页面卸载时触发(destroy)，如redirectTo或navigateBack到其他页面时。</p>
<h5 id="小程序页面有哪些传递数据的方法"><a href="#小程序页面有哪些传递数据的方法" class="headerlink" title="小程序页面有哪些传递数据的方法"></a>小程序页面有哪些传递数据的方法</h5><ol>
<li>使用全局变量实现数据传递</li>
<li>页面跳转或重定向时，使用url带参数传递数据</li>
<li>使用组件模板 template传递参数</li>
<li>使用缓存传递参数</li>
<li>使用数据库传递数据</li>
</ol>
<h5 id="请谈谈微信小程序主要目录和文件的作用？"><a href="#请谈谈微信小程序主要目录和文件的作用？" class="headerlink" title="请谈谈微信小程序主要目录和文件的作用？"></a>请谈谈微信小程序主要目录和文件的作用？</h5><ul>
<li>project.config.json 项目配置文件，用得最多的就是配置是否开启https校验；</li>
<li>App.js   设置一些全局的基础数据等；</li>
<li>App.json 底部tab, 标题栏, 小程序的window背景色和路由等设置；</li>
<li>App.wxss 公共样式，引入iconfont等；</li>
<li>pages 里面包含一个个具体的页面；<ul>
<li>index.json (配置当前页面标题和引入组件等)；</li>
<li>index.wxml (页面结构)；</li>
<li>index.wxss (页面样式表)；</li>
<li>index.js (页面的逻辑，请求和数据处理等)；</li>
</ul>
</li>
</ul>
<h5 id="谈谈微信小程序-wxss样式"><a href="#谈谈微信小程序-wxss样式" class="headerlink" title="谈谈微信小程序.wxss样式"></a>谈谈微信小程序.wxss样式</h5><ol>
<li>新增加了尺寸单位rpx(tip: rpx换算px规则是屏幕宽度/750, iphone6下，1rpx = 0.5px)</li>
<li>提供了全局样式(app.wxss)和局部样式(page.wxss)</li>
<li>WXSS 仅支持部分 CSS 选择器( &gt;  :first-of-type :nth-child 均不支持)</li>
</ol>
<h4 id="七、HTTP协议"><a href="#七、HTTP协议" class="headerlink" title="七、HTTP协议"></a>七、HTTP协议</h4><h5 id="HTTP请求中的内容"><a href="#HTTP请求中的内容" class="headerlink" title="HTTP请求中的内容"></a>HTTP请求中的内容</h5><ul>
<li>请求行 <code>GET /images/logo.gif HTTP/1.1</code></li>
<li>首部<ul>
<li>通用首部</li>
<li>请求首部</li>
<li>响应首部</li>
<li>实体首部</li>
</ul>
</li>
<li>实体<h5 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h5></li>
<li>1**: 信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2**: 成功，操作被成功接收并处理</li>
<li>3**: 重定向，需要进一步的操作以完成请求<ul>
<li>304 Not Modified 所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。</li>
</ul>
</li>
<li>4**: 客户端错误，请求包含语法错误或无法完成请求<ul>
<li>400 客户端请求的语法错误，服务端无法理解</li>
<li>403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求</li>
<li>404 Not Found 服务器无法根据客户端的请求找到资源（网页）</li>
</ul>
</li>
<li>5**: 服务器错误，服务器在处理请求的过程中发生了错误<ul>
<li>500 服务器内部错误</li>
<li>502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应<h5 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h5>往返时延，在计算机网络中它也是一个重要的性能指标，它表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延;<h5 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h5>只是数据报文的搬运工，不会对报文进行拆分和拼接操作，不保证有序且不丢失的传递到对端</li>
</ul>
</li>
<li>面向无连接</li>
<li>不可靠 -&gt; 高效</li>
</ul>
<p>在直播行业和即时对战游戏等实时性要求高的行业，UDP协议使用广泛</p>
<h5 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h5><p>TCP 基本是和 UDP 反着来，建立连接断开连接都需要先需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比 UDP 来说不那么的高效。是全双工协议。</p>
<h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><ul>
<li>URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。</li>
<li>ACK=1：代表确认接受,确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。</li>
<li>PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。</li>
<li>RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li>
<li>SYN=1：代表请求创立连接，当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。</li>
<li>FIN=1：代表请求释放连接。</li>
<li>seq：序列号，什么意思呢？当发送一个数据时，数据是被拆成多个数据包来发送，序列号就是对每个数据包进行编号，这样接受方才能对数据包进行再次拼接。</li>
<li>ack：这个代表下一个数据包的编号，这也就是为什么第二请求时，ack是seq + 1（tip: ack和ACK代表的意思不同）<h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5>客户端 —— SYN = 1, ACK = 0, seq = x ——- &gt; 服务端</li>
</ul>
<p>客户端 &lt; —– SYN = 1, ACK = 1, seq = y, ack = x + 1 ——– 服务端</p>
<p>客户端 —— ACK = 1, seq = x + 1, ack = y + 1——- &gt; 服务端</p>
<h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p>客户端 —— FIN ——- &gt; 服务端</p>
<p>客户端 &lt; —– ACK ——– 服务端</p>
<p>客户端 &lt; —– FIN ——– 服务端</p>
<p>客户端 —— ACK ——- &gt; 服务端</p>
<h5 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h5><p>ARQ协议其实就是超时重传机制。通过确认和超时重传机制保证数据的正确送达。</p>
<ul>
<li>停止等待ARQ协议</li>
<li>连续ARQ协议<h5 id="连续ARQ协议-gt-滑动窗口"><a href="#连续ARQ协议-gt-滑动窗口" class="headerlink" title="连续ARQ协议 - &gt; 滑动窗口"></a>连续ARQ协议 - &gt; 滑动窗口</h5>发送端窗口包含<code>已发送但未收到应答的数据</code>和<code>待发送的数据</code></li>
</ul>
<p>发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。</p>
<p>滑动窗口解决了数据的丢包、顺序不对和流量控制问题</p>
<h5 id="拥塞处理"><a href="#拥塞处理" class="headerlink" title="拥塞处理"></a>拥塞处理</h5><ul>
<li>慢开始算法</li>
<li>拥塞避免算法</li>
<li>快速重传</li>
<li>快速恢复<h4 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h4><h5 id="面向对象的基本要素"><a href="#面向对象的基本要素" class="headerlink" title="面向对象的基本要素"></a>面向对象的基本要素</h5><code>继承</code> <code>封装</code>和<code>多态</code><h5 id="JS适合用来面向对象吗？"><a href="#JS适合用来面向对象吗？" class="headerlink" title="JS适合用来面向对象吗？"></a>JS适合用来面向对象吗？</h5><h5 id="你在工作中是如何使用面向对象思想的？"><a href="#你在工作中是如何使用面向对象思想的？" class="headerlink" title="你在工作中是如何使用面向对象思想的？"></a>你在工作中是如何使用面向对象思想的？</h5></li>
</ul>
<p>明天需要上班，后续跟进补充！</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/blog/2019/06/29/20190629/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">你必须要明白的代理那些事儿</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/blog/2018/08/26/20180826/">
                        <span class="hidden-mobile">一道JavaScript面向对象的面试题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/blog/js/debouncer.js" ></script>
<script  src="/blog/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/blog/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/blog/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/blog/js/local-search.js" ></script>
  <script>
    var path = "/blog/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
